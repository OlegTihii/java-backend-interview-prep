+++
title = 'Многопоточность'
weight = 7
bookFlatSection = true
+++

## Многопоточность

#### 1. Что такое многопоточность?
Возможность программы выполнять несколько блоков одновременно

---
***Что такое поток?***


---
***Зачем нужны потоки?***


---
#### 2. Чем процесс отличается от потока?
*Процесс* - это экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы

*Поток* - способ выполнения *процесса*, определяющий последовательность исполнения кода в процессе. *Поток* всегда создается в контексте какого-либо *процесса*

---
#### 3. Чем Thread отличается от Runnable? Когда использовать Thread, а когда Runnable?
*Thread* - класс-надстройка над физическим потоком.

*Runnable* - интерфейс, представляющий абстракцию над выполняемой задачей.

- **Thread**. Используйте, если вам нужно управлять самим потоком
- **Runnable**. Используйте, если нужно просто выполнить задачу в потоке. Он более гибок и позволяет переиспользовать логику задачи в разных потоках

---
#### 4. Что такое монитор? Как реализован в Java?
*Монитор* - механизм синхронизации потоков, обеспечивающий доступ к общему ресурсу. В Java реализован с помощью ключевого слова `synchronized`

---
#### 5. Что такое синхронизация? Какие способы синхронизации существуют в Java?
*Синхронизация* - процесс, позволяющий выполнять потоки параллельно. Способы синхронизации в Java:

- Блок `sychronized` 

```java
public class Counter {

    private int count;

    public synchronized void increment() { //Если много потоков инкрементируют поле у одного объекта
        count++;
    }
```

- `join()` Поток вызвавший этот метод будет ждать до тех пор, пока объект, у которого был вызван этот метод - не закончит свое выполнение

```java
public static void main(String[] args) {
        SimpleThread simpleThread = new SimpleThread();
        simpleThread.start();
        try {
            simpleThread.join(); //До тех пор, пока этот поток не завершит свою работу - мы не пойдем дальше
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(Thread.currentThread().getName());
    } 
```

- Классы из пакета `java.util.concurrent` - **Lock**, **Semaphore**. Концепция данного подхода заключается в использовании атомарных операций и переменных
  
**Semaphore** позволяет задать какое кол-во потоков может получить доступ к ресурсу одновременно

---
#### 6. Что такое FutureTask?
*FutureTask* — это специальный объект в Java, который выполняет задачу в отдельном потоке и позволяет получить результат этой задачи, когда она завершится. Если задача ещё не закончена, попытка получить результат приостановит (заблокирует) выполнение, пока задача не завершится.

`FutureTask` — это реализация интерфейса `RunnableFuture`, который объединяет функциональность интерфейсов `Runnable` и `Future`. Этот класс позволяет выполнять задачу асинхронно, а затем получать её результат или обработать исключения.

---
***Что такое Future?***

`Future` — интерфейс, который предоставляет методы для работы с асинхронными результатами. Он используется в комбинации с `ExecutorService` или другими асинхронными API.

---
***Что такое CompletableFuture?***

`CompletableFuture` — это расширенная реализация интерфейса `Future`, которая добавляет возможность функционального программирования и работы с несколькими асинхронными задачами.

**Сравнение `FutureTask`, `Future` и `CompletableFuture`**

| **Особенность**            | **FutureTask** | **Future** | **CompletableFuture**                |
| -------------------------- | -------------- | ---------- | ------------------------------------ |
| **Асинхронное выполнение** | Да             | Да         | Да                                   |
| **Получение результата**   | `get()`        | `get()`    | Неблокирующие методы (`thenApply`)   |
| **Отмена задачи**          | Да             | Да         | Да                                   |
| **Композиция задач**       | Нет            | Нет        | Да (`thenCombine`, `allOf`, `anyOf`) |
| **Функциональный стиль**   | Нет            | Нет        | Да                                   |
| **Сложность**              | Простая        | Простая    | Расширенная функциональность         |


1. **`FutureTask`**: Комбинация `Runnable` и `Future`, используется для выполнения асинхронных задач вручную.
2. **`Future`**: Интерфейс для асинхронных операций, с базовыми методами (`get`, `cancel`).
3. **`CompletableFuture`**: Современный и мощный инструмент для асинхронного программирования с поддержкой композиции и функционального стиля.

---
#### 7. Что такое ExecutorService?
Это интерфейс в Java, который помогает управлять потоками более эффективно. Вместо создания новых потоков вручную - можно использовать его для выполнения задач в пулах потоков

---
#### 8. Как работать с коллекциями в многопоточном программировании?
- Превратить обычную коллекцию - в синхронизированную, с помощью *Collections.synchronized()*
  - `List<String> list = Collections.synchronizedList(new ArrayList<>())`

- Если работа с коллекцией состоит в основном из чтения - *CopyOnWriteArrayList<>()*
  - `List<String> list = new CopyOnWriteArrayList<>()`

- Использование Concurrent-коллекций:
  - Неблокирующие хеш-таблицы (*ConcurrentSkipListMap*, *ConcurrentHashMap*, *ConcurrentSkipListSet*)
  - Неблокирующие очереди (*ConcurrentLinkedQueue* и *ConcurrentLinkedDeque*)

---
***Почему мы должны использовать потокобезопасные коллекции?***


---
***CopyOnWriteCollections. Что это? Как происходит запись?***

Это потокобезопасные коллекции (*CopyOnWriteArrayList*, *CopyOnWriteArraySet*).
Как происходит запись:
- При добавлении элемента создается новая копия всей коллекции с добавленным изменением
- После завершения операции, оригинальная коллекция заменяется на новую копию, а все другие потоки продолжают работать со старой версией, пока новая не станет доступной

>Стоит использовать, когда в программе много операций чтения

---
***ConcurrentHashMap. Что это? Как происходит запись?***

Это потокобезопасная реализация хеш-таблицы.
Как происходит запись:

- *Хеширование ключа.* Сначала вычисляется хеш для ключа, что бы определить, в какой сегмент хеш-таблицы попадет этот элемент
- *Блокировка сегмента.* Блокируется только тот сегмент, в который будет добавлен этот элемент
- *Добавление элемента.* Элемент добавляется - блокировка с сегмента снимается


---
#### 9. SynchronizedCollections. Что это? За счет чего достигается потокобезопасность?
Это специальные коллекции в Java, которые обеспечивают потокобезопасность. Обеспечивается потокобезопасность за счет того, что все методы помечены как `synchronized`

---
#### 10. Проблемы многопоточности

***Что такое Deadlock?***

Это ситуация, когда два или более потока навсегда блокируются, ожидая ресурсы, которые уже захвачены другими потоками (**Thread A** ожидает **Thread B**, а **Thread B** ожидает **Thread A**)

---
***Что такое Livelock?***

Несколько потоков попадают в зацикленность при попытке получения каких-либо ресурсов. При этом их состояние постоянно изменяется (Два человека постоянно пытаются уступить друг другу дорогу. Каждый раз когда один делает шаг в сторону, другой делает то же самое)

---
***Что такое Race condition?***

Это ситуация, при которой результат выполнения программы зависит от порядка выполнения потоков. Возникает, когда несколько потоков одновременно обращаются к разделяемым ресурсам, и результат работы зависит от того, какой поток первым выполнит операции

---
#### 11. Atomic vs Valotile
**Atomic** — классы (AtomicInteger, AtomicLong, и т.д.), которые предоставляют атомарные операции для работы с примитивами. Они используют внутренние механизмы для обеспечения безопасности при изменении значений без блокировок

**Volatile** — ключевое слово, которое гарантирует, что значение переменной всегда будет читаться из памяти, а не из кэша потока. Каждый поток будет видеть актуальное значение valotile переменной, но если два потока одновременно изменяют переменную, могут возникнуть проблемы

---
***Когда что использовать?***

- **`volatile`**:
    
    - Когда нужно гарантировать только видимость изменений.
    - Например, для флагов завершения или состояния.
- **`Atomic`**:
    
    - Когда требуется атомарность (инкремент, сравнение и установка значений).
    - Например, для многопоточных счетчиков, индексов, обновлений.


**Сравнение `volatile` и `Atomic`**

|**Характеристика**|**`volatile`**|**`Atomic`**|
|---|---|---|
|**Гарантия видимости**|Да|Да|
|**Атомарные операции**|Нет|Да|
|**Использование**|Для простого чтения/записи|Для сложных операций (инкремент, CAS)|
|**Пример подходящих случаев**|Флаги (`boolean isRunning`)|Счётчики (`AtomicInteger.incrementAndGet`)|
|**Производительность**|Выше, так как операции проще|Чуть ниже из-за механизмов синхронизации|


---
***Зачем нужны atomic?*** 


---
***Зачем нужны valotile?***


---
#### 12. Какие бывают состояния у потока?
{{< figure src="Life_Cycle_of_Thread.png" title="Multithreading">}}

---
#### 13. Collections.synchronizedMap vs ConcurrentHashMap

---
#### 14. Какими способами можем запустить несколько потоков в Java приложении? Как запустить поток в Java?

---
#### 15. Что за интерфейсы Runnable и Callable? В чем между ними отличия?

---
#### 16. Расскажи про пакет cuncurrent

---
#### 17. Способы решения задач для многопоточного доступа

---
#### 18. Чем конкурентность отличается от параллелизма?

---
#### 19. Что такое CAS операции? (Compare And Swap)

---
#### 20. Асинхронность vs многопоточность

---
#### 21. Зачем нужны пулы потоков?

---
#### 22. Что значит потокобезопасность?