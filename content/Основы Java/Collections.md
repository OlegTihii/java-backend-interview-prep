+++
title = 'Коллекции'
weight = 2
bookFlatSection = true
+++

## Коллекции

> **Обязательно к прочтению**
> - ArrayList - https://habr.com/ru/articles/128269/ 
> - LinkedList - https://habr.com/ru/articles/127864/
> - HashMap - https://habr.com/ru/articles/128017/

#### 1. Расскажите как выглядит иерархия коллекций
{{< figure src="Collections.png" >}}

**Collection** и **Map** - два интерфейса, которые находятся на вершине иерархии JCF. Интерфейс Collection расширяют интерфейсы:
- List
- Queue
- Set

#### 2. Что такое ArrayList?
  Это список, реализованный на основе динамически расширяемого массива. То есть под капотом буквально создается массив

#### 3. ArrayList. Какая размерность массива по умолчанию?
Capacity = 10

***Можно ли задать начальную емкость/размер списка?***

Да, через конструктор (`List<String> list = new ArrayList<String>(15)`)

#### 4. ArrayList. Что происходит под капотом при добавлении/удалении элемента в начало/середину/конец списка?
**Добавление в конец списка:**

Проверяется достаточно ли места для добавления нового элемента. Если достаточно, то он просто добавляется в конец. Иначе:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

**Добавление в середину списка:**

Проверяется, достаточно ли места при добавлении нового элемента. Если достаточно - все элементы сдвигаются на один вправо. Если места недостаточно - происходит:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

#### 5. ArrayList. Какая скорость добавления элемента в начало/середину/конец списка?
 Начало списка: **О(n)**

 Середину списка: **О(n)**

  Конец списка: **О(1)**

#### 6. ArrayList. Какая скорость удаления элемента в начале/середине/конце списка?
  Начало списка: **О(n)**

  Середина списка: **О(n)**

  Конец списка: **О(1)**

#### 7. ArrayList. Какая скорость доступа по индексу и значению
По индексу: **О(1)**

По значению: **О(n)** (т.к нужно итерироваться по всему списку пока не найдем нужное значение)

#### 8. Сложность по времени ArrayList.contains()
!!!
#### 9. Что такое LinkedList?
Классический двусвязный список, основанный на объектах с ссылками между ними. Реализует интерфейсы List и Deque. Данные хранятся в объектах типа Nod-ах

#### 10. LinkedList. Что происходит под капотом при добавлении/удалении элемента в начало/середину/конец списка?
При создании LinkedList-а, у нас создается псевдо элемент - `Header` в котором хранятся next и prev, которые пока указывают сами на себя. После добавления элемента, ссылки next и prev у каждого объекта будут указывать на предыдущий и следующий.

#### 11. LinkedList. Какая скорость добавления элемента в начало/середину/конец списка?
  Начало списка: **О(1)**

  Середину списка: **О(n)**

  Конец списка: **О(1)**

#### 12. LinkedList. Какая скорость удаления элемента в начале/середине/конце списка?
  Начала списка: **О(1)**

  Середину списка: **О(n)**

  Конец списка: **О(1)**

#### 13. LinkedList. Какая скорость доступа по индексу и значению
  С начала и конца: **О(1)** (т.к есть доступ к первому и последнему элементу)

  С середины: **О(n)**

#### 14. ArrayList vs LinkedList
!!!

***Как лежат в памяти?***

!!!

***Где какой использовать?***

!!!

***Какая скорость вставки в отсортированный массив ArrayList и LinkedList***

!!!

#### 15. Что такое TreeMap?
Класс в Java, который реализует интерфейс `NavigableMap`, который в свою очередь наследуется от `SortedMap`. Представляет собой ассоциативный массив, где ключи отсортированы в их естественным порядком
Единственная коллекция, которая **не использует** `equeals()` и `hashCode()` 
Основана на красно-черных деревьях

#### 16. Какая скорость операций у TreeMap?
**О(log n)** (т.к каждый раз отметается половина)

#### 17. Устройство TreeMap
Древовидная структура: под капотом TreeMap использует структуру данных, которая называется **красно-чёрное дерево**.

#### 18. Что такое HashMap?
Ассоциативный массив, хранит пары "ключ-значение". Ключ-уникальный, значение-может повторяться. Каждая ячейка массива - бакет(корзина), хранящий в себе односвязный список узлов. Если у односвязного списка node больше 8 элементов (коллизии), он превращается в красно-чёрное дерево, обратно - если количество элементов в бакете уменьшилось до 6. Может содержать один ключ null и любое количество значений null. Не отсортирован и не упорядочен

#### 19. Что такое бакет?
В **HashMap** бакет — это элемент массива, в котором хранятся записи (ключ-значение). Если у нескольких ключей совпадает хеш, их записи попадают в один бакет, где организуются в виде связного списка или сбалансированного дерева (в зависимости от Java версии).

***Сколько изначально бакетов создается?***

 По умолчанию - **16**

***В каком случае количество бакетов увеличивается?***

Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

***Чтобы определить номер бакета есть формула. Какие в ней переменные?***

!!!

#### 20. Какая скорость операций?
  **О(1)**. Благодаря хеш-коду

#### 21. Опишите, как проходит процесс добавления объекта?
1. Вычисляется хеш-код ключ, на основании которого вычисляется бакет, в который будет добавлен новый элемент
2. Если бакет пустой - просто добавляем элемент
3. Если нет - идем по списку и сравниваем ключ добавляемого элемента и ключ элемента в списке по хеш-кодам
4. Если хеш-коды не равны - идем к следующему элементу
5. Если равны - сравниваем по `equals()`
6. Если ключи равны по `equals()` - перезаписываем value по этому ключу
7. Если ключи не равны по `equals()` - переходим к следующему элементу
8. Если мы не нашли ключ в списке, то добавляем этот элемент в конец списка
9. Так до тех пор, пока новое значение не перезапишет некоторое старое, или не достигнет конца односвязного списка и сохранится там последним элементом

#### 22. Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет своим преимущества

#### 23. Ключи в HashMap	
***Почему предпочтительно использовать в качестве ключа immutable объект?***

Потому что, если изменить объект на котором основан ключ, то у него поменяется хеш-код ⇒ найти элемент в HashMap-е не получится. Именно поэтому предпочтительно использовать immutable объекты (например String)

***HashMap. Собственный объект в качестве ключа***

!!!

***Почему строка является популярным ключом в HashMap?***
1. Иммутабельность (неизменяемость)
2. Хорошая реализация методов `hashCode()` и `equals()`

#### 24. Что такое HashSet?
HashSet — коллекция, не содержащая в себе дубликатов

#### 25. Как HashSet связан с HashMap?
HashSet использует HashMap для хранения элементов

#### 26. Сколько изначально бакетов создается? В каком случае количество бакетов увеличивается?
  По умолчанию создается - **16**

***Увеличивается***
если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

#### 27. Какая скорость операций?
  **О(1)**. Благодаря хеш-коду

#### 28. Как проходит процесс добавления элемента в HashSet?
1. Получаем hashCode объекта, который мы помещаем в hashSet
2. Определяем в какой бакет класть объект (остаток от деления хеш-кода на кол-во бакетов)
3. Проверяется, существует ли уже элемент в бакете
4. Если нет - то элемент добавляется в бакет. Если есть - добавление игнорируется, т.к HashSet не допускает дубликатов

>P.S. Перед добавлением элемента - проверка. Если кол-во элементов == кол-ву бакетов - количество бакетов увеличивается на х2

#### 29. Будет ли работать HashSet, если все добавляемые элементы будут иметь одинаковый hashCode()?
Да, будет, но его производительность ухудшится. Если все элементы имеют одинаковый хеш-код, они все будут размещены в одном бакете, что приведет к увеличению времени поиска

#### 30. Что такое Queue?
Queue - это интерфейс в Java, который представляет собой коллекцию элементов, работающую по принципу "первый вошел — первый вышел" (**FIFO** — First In, First Out). 

#### 31. Какая скорость операций?
  **О(1)**

#### 32. Назовите главные реализации Queue?
1. LinkedList
2. ArrayDeque

#### 33. Что такое Deque?
Deque (Double-Ended Queue) — это интерфейс в Java, который представляет собой очередь с двумя концами. Это означает, что элементы могут быть добавлены или удалены как с начала, так и с конца очереди. Таким образом, Deque может работать как очередь (**FIFO**) и как стек (**LIFO**).

***Что значит двунаправленный?***

Двунаправленный (или двухсторонний) в контексте Deque (Double-Ended Queue) означает, что элементы можно добавлять и удалять с обеих сторон очереди

#### 34. Назовите главные реализации Deque?
1. LinkedList
2. ArrayDeque (Double ended queue)

#### 35. Какая скорость операций Deque?
  **О(1)**

#### 36. Какая коллекция реализует дисциплину обслуживания LIFO? FIFO?
- Deque

#### 37. HashMap vs TreeMap
!!!

#### 38. Как с собой связаны Iterable и foreach?
!!!

***Если мы будем итерироваться по Коллекции, мы можем удалить элемент?***

!!!

***Виды итераторов. Fail-Fast vs Fail-Safe***

!!!

#### 39. Реализации интерфейса Map. Почему интерфейс Map выделен отдельно?
!!!
#### 40. Какую коллекцию использовать для уникальных отсортированных значений?
!!!
#### 41. HashTable - что это такое?
!!!
#### 42. Arrays.asList() and List.of()
!!!