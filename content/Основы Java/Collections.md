+++
title = 'Коллекции'
weight = 2
bookFlatSection = true
+++

## Коллекции

> **Обязательно к прочтению**
> - ArrayList - https://habr.com/ru/articles/128269/ 
> - LinkedList - https://habr.com/ru/articles/127864/
> - HashMap - https://habr.com/ru/articles/128017/

#### 1. Расскажите как выглядит иерархия коллекций
{{< figure src="Collections.png" >}}

**Collection** и **Map** - два интерфейса, которые находятся на вершине иерархии JCF. Интерфейс Collection расширяют интерфейсы:
- List
- Queue
- Set

---
#### 2. Что такое ArrayList?
  Это список, реализованный на основе динамически расширяемого массива. То есть под капотом буквально создается массив

---
#### 3. ArrayList. Какая размерность массива по умолчанию?
Capacity = 10

---
***Можно ли задать начальную емкость/размер списка?***

Да, через конструктор (`List<String> list = new ArrayList<String>(15)`)

---
#### 4. ArrayList. Что происходит под капотом при добавлении/удалении элемента в начало/середину/конец списка?
**Добавление в конец списка:**

Проверяется достаточно ли места для добавления нового элемента. Если достаточно, то он просто добавляется в конец. Иначе:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

---
**Добавление в середину списка:**

Проверяется, достаточно ли места при добавлении нового элемента. Если достаточно - все элементы сдвигаются на один вправо. Если места недостаточно - происходит:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

---
#### 5. ArrayList - сложность операций
*ArrayList* — это реализация динамического массива в Java. Основные характеристики производительности операций зависят от внутреннего устройства структуры данных

---
***ArrayList. Какая скорость добавления элемента в начало/середину/конец списка?***

| Место добавления    | Средняя сложность | Худшая сложность | Пояснение                                                                                     |
| ------------------- | ----------------- | ---------------- | --------------------------------------------------------------------------------------------- |
| **Начало списка**   | `O(n)`            | `O(n)`           | Все элементы сдвигаются вправо для освобождения места.                                        |
| **Середина списка** | `O(n)`            | `O(n)`           | Элементы после точки вставки сдвигаются вправо.                                               |
| **Конец списка**    | `O(1)`            | `O(n)`           | Амортизированная сложность `O(1)`, но если массив переполняется, требуется перераспределение. |

---
***ArrayList. Какая скорость удаления элемента в начале/середине/конце списка?***

| Место удаления      | Средняя сложность | Худшая сложность | Пояснение                                                                              |
| ------------------- | ----------------- | ---------------- | -------------------------------------------------------------------------------------- |
| **Начало списка**   | `O(n)`            | `O(n)`           | Все элементы сдвигаются влево для заполнения освободившегося места.                    |
| **Середина списка** | `O(n)`            | `O(n)`           | Элементы после удалённого элемента сдвигаются влево.                                   |
| **Конец списка**    | `O(1)`            | `O(1)`           | Удаление последнего элемента происходит мгновенно без необходимости сдвигать элементы. |

---
***ArrayList. Какая скорость доступа по индексу и значению?***

|Операция|Средняя сложность|Худшая сложность|Пояснение|
|---|---|---|---|
|**Доступ по индексу**|`O(1)`|`O(1)`|Прямой доступ к элементам массива за константное время благодаря индексации.|
|**Поиск по значению**|`O(n)`|`O(n)`|Линейный поиск, так как элементы не отсортированы и требуется перебор всех значений.|

---
***Сложность по времени ArrayList.contains()***

---
#### 6. Что такое LinkedList?
Классический двусвязный список, основанный на объектах с ссылками между ними. Реализует интерфейсы List и Deque. Данные хранятся в объектах типа Nod-ах

#### 7. LinkedList. Что происходит под капотом при добавлении/удалении элемента в начало/середину/конец списка?
При создании LinkedList-а, у нас создается псевдо элемент - `Header` в котором хранятся next и prev, которые пока указывают сами на себя. После добавления элемента, ссылки next и prev у каждого объекта будут указывать на предыдущий и следующий.

#### 8. LinkedList - сложность операций
В `LinkedList` элементы фактически представляют собой звенья одной цепи. У каждого элемента помимо тех данных, которые он хранит, имеется ссылка на предыдущий и следующий элемент. По этим ссылкам можно переходить от одного элемента к другому. 

---
***LinkedList. Какая скорость добавления элемента в начало/середину/конец списка?***

|Место добавления|Средняя сложность|Худшая сложность|Пояснение|
|---|---|---|---|
|**Начало списка**|`O(1)`|`O(1)`|Новый узел добавляется перед первым, переназначаются ссылки.|
|**Середина списка**|`O(n)`|`O(n)`|Требуется пройти список до нужного узла, после чего выполняется вставка.|
|**Конец списка**|`O(1)`|`O(1)`|Новый узел добавляется после последнего, переназначаются ссылки.|

---
***LinkedList. Какая скорость удаления элемента в начале/середине/конце списка?***

|Место удаления|Средняя сложность|Худшая сложность|Пояснение|
|---|---|---|---|
|**Начало списка**|`O(1)`|`O(1)`|Удаление первого узла выполняется мгновенно, ссылки переназначаются.|
|**Середина списка**|`O(n)`|`O(n)`|Требуется пройти список до нужного узла, после чего выполняется удаление.|
|**Конец списка**|`O(1)`|`O(1)`|Удаление последнего узла выполняется мгновенно, если есть доступ к последнему элементу.|

---
***LinkedList. Какая скорость доступа по индексу и значению***

|Тип доступа|Средняя сложность|Худшая сложность|Пояснение|
|---|---|---|---|
|**Доступ по первому элементу**|`O(1)`|`O(1)`|Первый элемент хранится в ссылке `head`, доступ к нему мгновенный.|
|**Доступ по последнему элементу**|`O(1)`|`O(1)`|Последний элемент хранится в ссылке `tail`, доступ к нему мгновенный.|
|**Доступ по индексу**|`O(n)`|`O(n)`|Линейный обход от начала или конца до нужного индекса.|
|**Доступ по значению**|`O(n)`|`O(n)`|Линейный перебор всех элементов до нахождения искомого значения.|

---
#### 9. ArrayList vs LinkedList
!!!

***Как лежат в памяти?***

!!!

***Где какой использовать?***

!!!

***Какая скорость вставки в отсортированный массив ArrayList и LinkedList***

!!!

#### 10. Что такое TreeMap?
Класс в Java, который реализует интерфейс `NavigableMap`, который в свою очередь наследуется от `SortedMap`. Представляет собой ассоциативный массив, где ключи отсортированы в их естественным порядком
Единственная коллекция, которая **не использует** `equeals()` и `hashCode()` 
Основана на красно-черных деревьях

#### 11. TreeMap - сложность операций
**О(log n)** (т.к каждый раз отметается половина)

#### 12. Внутреннее устройство TreeMap
Древовидная структура: под капотом TreeMap использует структуру данных, которая называется **красно-чёрное дерево**.

#### 13. Что такое HashMap?
Ассоциативный массив, хранит пары "ключ-значение". Ключ-уникальный, значение-может повторяться. Каждая ячейка массива - бакет(корзина), хранящий в себе односвязный список узлов. Если у односвязного списка node больше 8 элементов (коллизии), он превращается в красно-чёрное дерево, обратно - если количество элементов в бакете уменьшилось до 6. Может содержать один ключ null и любое количество значений null. Не отсортирован и не упорядочен

#### 14. Внутреннее устройство HashMap
В **HashMap** бакет — это элемент массива, в котором хранятся записи (ключ-значение). Если у нескольких ключей совпадает хеш, их записи попадают в один бакет, где организуются в виде связного списка или сбалансированного дерева (в зависимости от Java версии).

***Сколько изначально бакетов создается?***

 По умолчанию - **16**

***В каком случае количество бакетов увеличивается?***

Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

***Чтобы определить номер бакета есть формула. Какие в ней переменные?***

!!!

#### 15. HashMap - сложность операций

|Операция|Средняя сложность|Худшая сложность|Пояснение|
|---|---|---|---|
|**Добавление (`put`)**|`O(1)`|`O(n)`|В среднем: хеш-функция вычисляет индекс за константное время. В худшем случае — при множестве коллизий — все элементы хранятся в одной корзине как связный список или дерево (`O(n)`).|
|**Удаление (`remove`)**|`O(1)`|`O(n)`|Удаление элемента по ключу быстрое в среднем. При множестве коллизий потребуется обход корзины.|
|**Поиск (`get`)**|`O(1)`|`O(n)`|В среднем: доступ по хешу за константное время. В худшем случае — линейный обход корзины.|
|**Проверка наличия (`containsKey` / `containsValue`)**|`O(1)` / `O(n)`|`O(n)`|Проверка ключа быстрая в среднем (`O(1)`), для значений требуется полный перебор (`O(n)`).|
|**Итерация по элементам**|`O(n)`|`O(n)`|Обход всех элементов требует линейное время, так как необходимо пройти все корзины.|


#### 16. Процесс добавления объекта в HashMap
1. Вычисляется хеш-код ключ, на основании которого вычисляется бакет, в который будет добавлен новый элемент
2. Если бакет пустой - просто добавляем элемент
3. Если нет - идем по списку и сравниваем ключ добавляемого элемента и ключ элемента в списке по хеш-кодам
4. Если хеш-коды не равны - идем к следующему элементу
5. Если равны - сравниваем по `equals()`
6. Если ключи равны по `equals()` - перезаписываем value по этому ключу
7. Если ключи не равны по `equals()` - переходим к следующему элементу
8. Если мы не нашли ключ в списке, то добавляем этот элемент в конец списка
9. Так до тех пор, пока новое значение не перезапишет некоторое старое, или не достигнет конца односвязного списка и сохранится там последним элементом

#### 17. Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет своим преимущества

#### 18. Ключи в HashMap	
***Почему предпочтительно использовать в качестве ключа immutable объект?***

Потому что, если изменить объект на котором основан ключ, то у него поменяется хеш-код ⇒ найти элемент в HashMap-е не получится. Именно поэтому предпочтительно использовать immutable объекты (например String)

***HashMap. Собственный объект в качестве ключа***

!!!

***Почему строка является популярным ключом в HashMap?***
1. Иммутабельность (неизменяемость)
2. Хорошая реализация методов `hashCode()` и `equals()`

#### 19. Что такое HashSet?
HashSet — коллекция, не содержащая в себе дубликатов

#### 20. Как HashSet связан с HashMap?
HashSet использует HashMap для хранения элементов

#### 21. Внутреннее устройство HashSet

---
***Сколько изначально бакетов создается?***

  По умолчанию создается - **16**

---
***В каком случае количество бакетов увеличивается***

Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

---
#### 22. HashSet - сложность операций
  **О(1)**. Благодаря хеш-коду

#### 23. Процесс добавления объекта в HashSet?
1. Получаем hashCode объекта, который мы помещаем в hashSet
2. Определяем в какой бакет класть объект (остаток от деления хеш-кода на кол-во бакетов)
3. Проверяется, существует ли уже элемент в бакете
4. Если нет - то элемент добавляется в бакет. Если есть - добавление игнорируется, т.к HashSet не допускает дубликатов

>P.S. Перед добавлением элемента - проверка. Если кол-во элементов == кол-ву бакетов - количество бакетов увеличивается на х2

#### 24. Будет ли работать HashSet, если все добавляемые элементы будут иметь одинаковый hashCode()?
Да, будет, но его производительность ухудшится. Если все элементы имеют одинаковый хеш-код, они все будут размещены в одном бакете, что приведет к увеличению времени поиска

#### 25. Что такое Queue?
Queue - это интерфейс в Java, который представляет собой коллекцию элементов, работающую по принципу "первый вошел — первый вышел" (**FIFO** — First In, First Out). 

#### 26. Queue - сложность операций
  **О(1)**

#### 27. Назовите главные реализации Queue?
1. LinkedList
2. ArrayDeque

#### 28. Что такое Deque?
Deque (Double-Ended Queue) — это интерфейс в Java, который представляет собой очередь с двумя концами. Это означает, что элементы могут быть добавлены или удалены как с начала, так и с конца очереди. Таким образом, Deque может работать как очередь (**FIFO**) и как стек (**LIFO**).

***Что значит двунаправленный?***

Двунаправленный (или двухсторонний) в контексте Deque (Double-Ended Queue) означает, что элементы можно добавлять и удалять с обеих сторон очереди

#### 29. Назовите главные реализации Deque?
1. LinkedList
2. ArrayDeque (Double ended queue)

#### 30. Dequeue - сложность операций
  **О(1)**

#### 31. Какая коллекция реализует дисциплину обслуживания LIFO? FIFO?
- ArrayDeque

#### 32. HashMap vs TreeMap
!!!

#### 33. Как с собой связаны Iterable и foreach?
!!!

***Если мы будем итерироваться по Коллекции, мы можем удалить элемент?***

!!!

***Виды итераторов. Fail-Fast vs Fail-Safe***

!!!

#### 34. Реализации интерфейса Map. Почему интерфейс Map выделен отдельно?
!!!
#### 35. Какую коллекцию использовать для уникальных отсортированных значений?
!!!
#### 36. HashTable - что это такое?
!!!
#### 37. Arrays.asList() and List.of()
!!!