+++
title = 'Java Core'
weight = 1
bookFlatSection = true
+++

## Java Core

#### 1. Расскажи мне про контракт Equals&Hashcode
- Если два объекта возвращают разные значения `hashCode()`, то они не могут быть равны
- Если `equals()` объектов true, то и хеш-коды должны быть равны
- Переопределив `equals()`, всегда переопределять `hashCode()`
- Если у объектов одинаковый `hashCode()`, то они не обязательно `equals()` 
- При каждом вызове `hashCode()` для одного и того же объекта должен возвращаться один и тот же хеш-код

#### 2. Расскажи мне про свойства Equals&Hashcode
 **equals()**. Метод `equals` реализует отношение эквивалентности, которое обладает следующими свойствами:
  - **Рефлексивность**. Объект должен быть равен самому себе (`x.equals(x) == true`)
  - **Симметричность**. Любые два объекта должны иметь одно и то же мнение относительно своего равенства или неравенства (`x.equals(y) == true` и `y.equals(x) == true`)
  - **Транзитивность**. Если один объект равен второму, а второй равен третьему, то и первый объект должен быть равен третьему (`x.equals(y) == true` и `y.equals(z) == true` и `x.equals(z) == true`)
  - **Непротиворечивость**. Если два объекта эквивалентны, они должны быть эквивалентны всегда, пока один из них (или оба они) не будет изменен

  **hashCode():**
  - **Согласованность**. При каждом вызове `hashCode()` для одного и того же объекта в рамках одной программы должно возвращаться одно и то же значение, если поля объекта, участвующие в расчете хэш-кода, не изменились.
  - **Равенство и хэш-код.** Если два объекта равны по методу `equals()`, их хэш-коды тоже должны быть равны. Однако обратное не обязательно — объекты с одинаковым хэш-кодом могут быть не равны
  - **Распределение**. Хороший хэш-код должен распределять объекты по разным корзинам хэш-таблицы для эффективной работы хэш-структур данных, таких как HashMap или HashSet

#### 3. Что такое коллизия?
 Коллизия возникает, когда у разных объектов одинаковые хеш-коды

#### 4. Зачем переопределять методы equals в HashMap? 
  Методы `equals()` и `hashCode()` необходимо переопределять в классах, которые используются в качестве ключей в HashMap, чтобы обеспечить корректное поведение этой структуры данных:
  - `equals()`: Определяет, когда два объекта считаются равными. Если два объекта равны, их хэш-коды также должны быть равными.
  - `hashCode()`: Генерирует числовое значение, которое используется для определения корзины (bucket) в HashMap. Правильное переопределение важно, чтобы объекты, которые равны по `equals()`, имели одинаковый `hashCode()`. Иначе, одинаковые объекты могут попасть в разные корзины, что нарушит работу HashMap.

#### 5. Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?
- Объект, который по `equals()` равен существующему ключу в HashMap, может не быть найден, если их хэш-коды различаются. Это связано с тем, что HashMap сначала использует `hashCode()` для поиска корзины, а уже потом сравнивает объекты по `equals()`.
- При попытке удалить ключ, который равен другому ключу по `equals()`, но имеет другой `hashCode()`, удаление может не сработать.

#### 6. Какие типы ссылок существуют в Java?
- **Сильная ссылка.** Обычная ссылка, которая повсеместно используется (`Object obj = new Object()`). Объект не будет удален сборщиком мусора, пока на него есть хотя бы одна сильная ссылка
- **Мягкая ссылка.** Используются для кеширования. Объект, на который ссылается мягкая ссылка, будет удален сборщиком мусора только при нехватке памяти (`SoftReference<MyObject> softRef = new SoftReference<>(new MyObject())`)
- **Слабая ссылка.** Объект, на который ссылается слабая ссылка, может быть удален сборщиком мусора при следующей проверке, даже если на него есть слабые ссылки (`WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject())`)
- **Фантомная ссылка**. Используется для отслеживания, когда объект был удален из памяти. Фантомная ссылка не позволяет получить доступ к объекту напрямую, она только сигнализирует, что объект скоро будет удален (`PhantomReference<MyObject> phantomRef = new PhantomReference<>(new MyObject(), referenceQueue)`)

#### 7. Какой класс называют Immutable?
  Иммутабельный класс - класс, экземпляры которого не могут быть изменены после создания. Принципы создания:
  - Поля private `final`  
  - Никаких setter-ов
  - Сам класс делаем `final` 
  - Все поля устанавливаются через конструктор

#### 8. Основная идея языка.
 Написано однажды - работает везде

#### 9. За счет чего обеспечена кроссплатформенность?
 За счет создания виртуальной машины Java. Это что-то вроде прослойки между ОС и Java программой

#### 10. Какие преимущества Java?
- **Объектно-ориентированное программирование.** Структура данных становится объектом, которым можно управлять, создавать отношения между различными объектами.

- **Язык высокого уровня с простым синтаксисом и плавной кривой обучения.** Синтаксис Java основан на C ++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.
- **Стандарт для корпоративных вычислительных систем.**  Корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.
- **Безопасность.**  Благодаря отсутствию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").
- **Независимость от платформы.**  Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.
- **Язык для распределенного программирования и комфортной удаленной совместной работы.**   Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.
- **Автоматическое управление памятью.** (вопрос спорный: плюс или минус) Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).
- **Многопоточность.** Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.
- **Стабильность и сообщество.**  Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.

#### 11. Какие недостатки Java?
- Платное коммерческое использование (с 2019)
- Многословный код
- 
#### 12. JVM, JRE, JDK, JIT
- **JVM** - Виртуальная машина Java, которая исполняет байт-код
- **JRE** - Среда выполнения Java. Включает в себя JVM и стандартные библиотеки классов 
  - java.lang - String, System, Object
  - java.io - InputStream, OutputStream
  - java.util - коллекции (List, Set, Map)
- **JDK** - Набор инструментов для разработки. Включает в себя JRE, компилятор и другие утилиты
- **JIT** - компиляция байт-кода в машинный во время выполнения программы

#### 13. Что такое байт-код?
Набор инструкций исполняемый виртуальной машиной Java

#### 14. Что такое сборщик мусора (garbage collector)?
В Java используется автоматическое управление памятью. Программист выделяет память, а за освобождение отвечает JVM. Когда программа больше не ссылается на объект (прямые или косвенные ссылки), то объект удаляется, а память пере-
используется. Сборщик мусора – это демон-поток, который выполняет две задачи:
1. поиск 
2. очистка мусора.

#### 15. Разница между GC в разных версиях Java.
- JDK 8 сборщик Parallel
- JDK 9 сборщик G1
- JDK 15 сборщик ZGC

#### 16. Stack и heap. Что это такое?
**Stack** - это область хранения данных. Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Стек в Java работает по схеме LIFO (Последний зашел - Первый вышел)

**Heap** (куча) используется для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.

#### 17. В чём разница между stack и heap?
- Куча больше стека
- Стек хранит примитивы и ссылки на объекты, а куча хранит все созданные объекты
- Память стека существует пока выполняется текущий метод, а куча существует пока работает приложение
- Стек быстрее кучи

#### 18. Если объект содержит примитив, то где этот примитив будет храниться?
Объект с примитивом будет храниться в куче. Примитив этого объекта так же будет храниться в куче

#### 19. Примитивные типы данных + значения по умолчанию.
- byte (0) (8 бит)
- short (0) (16 бит)
- int (0) (32 бит)
- long (0L) (64 бит)
- float (0.0f) (32 бит)
- double (0.0d) (64 бит)
- char (\u0000) (16 бит)
- boolean (false) (зависит от JVM)

#### 20. Что такое класс-обертка?
Обертка - специальный класс, который хранит внутри себя значения примитива. Обертки являются Immutable

#### 21. Автоупаковка и автораспаковка.
- Автоупаковка - примитивный тип ⇒ объектный класс
- Автораспаковка - объектный класс ⇒ примитивный тип

#### 22. Какие нюансы у строк в Java?
Класс String - immutable из-за модификатора final и отсутствия сеттера. При редактировании строк будет создаваться новая строка

#### 23. Что такое пул строк?
Область памяти, где хранятся объекты строк. При создании в пуле строк происходит поиск строки:
- Если НЕ находит ⇒ создается строка, возвращается ссылка
- Если находит ⇒ возвращает ссылку найденной строки

#### 24. Что делает метод intern() в классе String?
Помещает строку в пул строк

#### 25. Почему не рекомендуется изменять строки в цикле?
Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать новую строку. Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – **StringBuffer** и **StringBuilder**.

#### 26. Разница между String, StringBuffer, StringBuilder.
- **String** - неизменяемый, потокобезопасный
- **StringBuffer** - изменяемый, потокобезопасный
- **StringBuilder** - изменяемый, потоко**НЕ**безопасный

#### 27. Каким образом переменные передаются в методы — по значению или по ссылке?
По значению. Всегда

#### 28. Что такое enum?
Enum - набор логически связанных констант. Нужны для ограничения области допустимых значений (времена года, дни недели)

#### 29. Что такое конструктор по умолчанию?
Если у класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый “конструктор по-умолчанию”

#### 30. Могут ли быть приватные конструкторы? Для чего они нужны?
Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса. Нужен для реализации паттернов `singleton`

```java
public class Singleton {
    // Статическое поле для хранения единственного экземпляра класса
    private static Singleton instance;

    // Приватный конструктор, предотвращающий создание экземпляров извне
    private Singleton() {}

    // Публичный метод для доступа к единственному экземпляру класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### 31. Чем отличаются конструкторы по умолчанию, конструктор копирования и конструктор с параметрами?"
- Конструктор по-умолчанию. Отсутствуют какие-либо параметры
- Конструктор копирования. Принимает в качестве аргумента уже существующий объект класса для последующего создания его клона
- Конструктор с параметрами имеет в своей сигнатуре аргументы

#### 32. Какие есть модификаторы доступа? Какие применимы к классам?
- `private`. Доступ только из этого класса, в котором объявлен
- `default`. Переменная доступна для любого другого класса в том же пакете
- `protected`. Переменная доступна всем классам внутри пакета, а так же всем классам-наследникам вне пакета
- `public`. Доступ к компоненту из любой точки программы

#### 33. Что означает static?
- `Static` переменная - переменная, принадлежащая классу, а не объекту
- `Static` класс - вложенный класс, который может обращаться только к статическим полям класса-обертки
- `Static` метод - метод, принадлежащий классу, а не объекту. Статические методы обращаются только к другим статическим методам и переменным

#### 34. Может ли статический метод быть переопределен?
Нельзя переопределять статические методы.
Если объявить такой же метод в классе-наследнике, то мы лишь «спрячем» метод суперкласса вместо переопределения. Это называется сокрытие методов.

*Прим.* Перегружать можно, переопределять нет. В случае со статическими методами это не
переопределение (overriding), а сокрытие (hiding).

#### 35. Могут ли нестатические методы перегружать статические?
Да. В итоге получится два разных метода. 
Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

#### 36. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?"
Можно расширить модификатор доступа и сузить тип возвращаемого значения (если они совместимы)

#### 37. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т. п.)?"
- В сигнатуре менять ничего нельзя. 
- Можно расширить уровень доступа. 
- Можно сузить тип возвращаемого значения. 
- Можно не указывать исключения, которые были объявлены в родительском классе.
- Можно так же добавить новые исключения, которые являются наследниками родительского, либо те, что наследуются от RuntimeException

#### 38. Могут ли классы быть статическими?
Да, вложенные классы

#### 39. Что означает модификатор final? К чему он может быть применим?
- `final` у класса. Запрещает наследование
- `final` у примитива. Запрещает изменение значения после присвоения
- `final` у ссылочной переменной. Запрещает изменение ссылки на объект
- `final` у массива. Запрещает изменение ссылки на массив (но можно менять элементы внутри)

#### 40. Что такое абстрактные классы? Чем они отличаются от обычных?
Абстрактным классом называется класс, у которого не может быть экземпляров. Может содержать абстрактные методы. Наследниками абстрактного класса могут быть другие абстрактные классы и обычные классы

#### 41. Может ли быть абстрактный класс без абстрактных методов?
Да, может

#### 42. Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?
Да, могут, если они нужны для наследников

#### 43. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?"
Интерфейс - группа методов с пустыми телами.
- Методы интерфейса - public abstract
- Поля - public static final

#### 44. Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?"
Абстрактные классы используются, когда есть отношение ‘is a’, а интерфейс может быть реализован классами, вовсе не связанными друг с другом
 
Так же можно унаследовать только один класс, но реализовать сколько угодно интерфейсов.

#### 45. Может ли один интерфейс наследоваться от другого? От двух других?
Да

#### 46. Что такое дефолтные методы интерфейсов? Для чего они нужны?
Default методы - это методы в интерфейсе, которые имеют тело и помечены default. Классы, реализующие такой интерфейс могут использовать этот код, либо же изменить его

#### 47. Каков порядок вызова конструкторов и  блоков инициализации с учетом иерархии классов?"
1. Статические блоки у родителя
2. Статический блок у наследника
3. Нестатический блок у родителя
4. Конструктор родителя
5. Нестатические блоки у наследника
6. Конструктор наследника

#### 48. Зачем нужны и какие бывают блоки инициализации?
Существуют статические и нестатические блоки инициализации. Нужны для инициализации

#### 49. Для чего в Java используются статические блоки инициализации?
Статические блоки инициализации используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов.

#### 50. Класс Object и его методы?
Object - базовый класс для всех объектов в Java. Любой класс так или иначе наследуется от Object, и, соответственно, наследует его методы:
- `equals()`
- `hashCode()`
- `toString()`
- `getClass()`
- `clone()`
- `finalize()`

А так же методы для многопоточности:
- `notify()`
- `notifyAll()`
- `wait()`

#### 51. Что такое сериализация и для чего она нужна?
Сериализация - это процесс сохранения объекта в последовательность байт. Реализована через интерфейс-маркер Serializable. Нужна для компактного сохранения состояния объекта и считывания этого состояния
