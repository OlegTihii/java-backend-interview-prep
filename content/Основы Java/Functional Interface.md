+++
title = 'Функциональные интерфейсы'
weight = 5
bookFlatSection = true
+++

## Функциональные интерфейсы

#### 1. Что такое функциональный интерфейс?
Функциональный интерфейс – интерфейс с одним абстрактным методом. Помимо одного абстрактного, может содержать любое количество статических и дефолтных методов.

---
#### 2. Для чего нужна аннотация `@FunctionalInterface`
Для гарантии того, что интерфейс является функциональным. Она не даст создать еще один абстрактный метод

---
#### 3. Какие встроенные функциональные интерфейсы вы знаете?
- `Predicate<T>` – принимает объект типа T и проверяет соблюдение некоторого условия и возвращает результат типа Boolean

- `BiPredicate<T, U>` - принимает два объекта типов T и U и проверяет соблюдение некоторого условия и возвращает результат типа Boolean

- `Consumer<T>` - принимает объект, совершает некоторые действия, но при этом ничего не возвращает.

- `BiConsumer<T, U>` - принимает два объекта типов T и U, совершает некоторые действия, но при этом ничего не возвращает.

- `Supplier<T>` - не принимает никаких аргументов, но возвращает некоторый объект T.

- `Function<T, R>` - принимает аргумент T и приводит его к объекту типа R, который и возвращается как результат.

- `BiFunction<T, U, R>` - принимает два аргумента типа T и U и приводит их к объекту типа R, который и возвращается как результат

- `UnaryOperator<T>` - принимает в качестве параметра объект T, выполняет над ним некоторые операции и возвращает результат операций в виде объекта того же типа.

- `BinaryOperator<T>` – принимает два аргумента типа T и возвращает объект того же типа.

---
#### 4. Что такое ссылка на метод?
*Ссылка на метод* - сокращенная запись для лямбда-выражений, которая позволяет ссылаться на уже существующий метод и использовать его как функциональный интерфейс

---
#### 5. Что такое лямбда выражение? Чем его можно заменить?
*Лямбда* – набор инструкций, которые можно выделить в отдельную переменную и затем многократно использовать. Являются сокращённой формой внутренних анонимных классов.

---
***Чем его можно заменить?***
1. Анонимным классом
2. Обычным классом, реализующим интерфейс
3. Ссылкой на метод (method reference)

---
***Анонимный класс vs лямбда***

Это два способа реализации интерфейсов или создания компактного кода в Java. Они имеют сходства, но различаются по способу использования, синтаксису и некоторым ограничениям.

*Анонимный класс* — это локальный класс без имени, который объявляется и создаётся одновременно.

*Лямбда* — это краткий способ объявления реализации функционального интерфейса (интерфейса с одним методом).

| **Критерий**               | **Анонимный класс**                                           | **Лямбда-выражение**                                  |
|----------------------------|-------------------------------------------------------------|-----------------------------------------------------|
| **Синтаксис**              | Более громоздкий                                            | Краткий и лаконичный                                |
| **Совместимость**          | Любой интерфейс или класс                                    | Только функциональный интерфейс                    |
| **Использование `this`**   | Ссылается на экземпляр анонимного класса                    | Ссылается на экземпляр внешнего класса             |
| **Многометодные интерфейсы**| Можно переопределять несколько методов                     | Не поддерживается (только один метод)              |
| **Поддержка переменных**   | Может содержать свои переменные и методы                    | Не может содержать свои методы или поля            |
| **Производительность**     | Более ресурсоёмкий (создаёт новый класс)                    | Оптимизирован JVM (не создаёт новый объект класса) |

---
#### 6. Что делает Интерфейс Function
`java.util.function.Function`  - это встроенный функциональный интерфейс, добавленный в Java SE 8.

Принимает значение в качестве аргумента одного типа и возвращает другое значение. Часто используется для преобразования одного значения в другое:

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

