+++
title = 'Дженерики'
weight = 4
bookFlatSection = true
+++

## Дженерики

#### 1. Что такое дженерики? Для чего нужны?
Дженерики - параметризованные типы в Java

- Что это? Позволяют создавать классы, интерфейсы и методы с типами, заданными как параметры
- Зачем нужны? Позволяют использовать один класс для разных типов данных (`List<String>`, `List<Integer>`)

---
#### 2. Что такое сырые типы?
Сырые типы - это использование обобщенных классов без указания типов

---
#### 3. Что такое вайлдкард
Вайлдкарды - это символ ‘?’, который используется для обозначения неизвестного типа в дженериках

---
#### 4. Расскажите про принципе PECS
- Producer. Используется для чтения (? extends T)
- Consumer. Используется для добавления (? super T)
- Оба действия. Использовать конкретный тип, а не wildcard

---
#### 5. Расскажите про класс Optional
Optional - Класс-обертка. Он помогает избежать ошибок, связанных с null

---
***Что делает Optional.flatMap()***

`Optional.flatMap()` используется для работы с вложенными объектами `Optional`, помогая избежать двойной обёртки.



```java
Optional<String> getNestedValue(Optional<Optional<String>> nestedOpt) {
    return nestedOpt.flatMap(opt -> opt);
}

```
- Убирает вложенность: из `Optional<Optional<T>>` превращает в `Optional<T>`.

Используйте `map`, если функция возвращает нужный вам объект, или `flatMap`, если функция возвращает `Optional` объект.

---
#### 6. Как JVM работает с Generics

- JVM не хранит информацию о параметризованных типах в рантайме.
- Все операции с дженериками преобразуются в операции с "сырыми типами" (raw types) на этапе компиляции.

---
***Что такое стирание типов?***

**Стирание типов (Type Erasure)** — процесс, при котором информация о дженериках удаляется во время компиляции. JVM видит только "сырой" тип.

---
***Generics. Можно ли получить тип в рантайме?***

Нет, в общем случае нельзя. В Java используется **стирание типов** (Type Erasure), что означает, что информация о параметризованных типах удаляется после компиляции. На этапе выполнения JVM работает только с "сырыми типами" (`raw types`).

**Исключение:** Можно сохранить информацию о типах с помощью рефлексии или через использование классов-обёрток.  

Пример с `TypeToken`:

```java
import java.lang.reflect.Type;
import com.google.gson.reflect.TypeToken;

Type type = new TypeToken<List<String>>(){}.getType();
System.out.println(type); // java.util.List<java.lang.String>

```

