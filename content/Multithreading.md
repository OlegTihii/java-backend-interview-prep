## MULTITHREADING

#### 1. Что такое многопоточность?
Возможность программы выполнять несколько блоков одновременно

#### 2. Чем процесс отличается от потока?
*Процесс* - это экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы

*Поток* - способ выполнения *процесса*, определяющий последовательность исполнения кода в процессе. *Поток* всегда создается в контексте какого-либо *процесса*

#### 3. Чем Thread отличается от Runnable? Когда использовать Thread, а когда Runnable?
*Thread* - класс-надстройка над физическим потоком.

*Runnable* - интерфейс, представляющий абстракцию над выполняемой задачей.

- **Thread**. Используйте, если вам нужно управлять самим потоком
- **Runnable**. Используйте, если нужно просто выполнить задачу в потоке. Он более гибок и позволяет переиспользовать логику задачи в разных потоках

#### 4. Что такое монитор? Как реализован в Java?
*Монитор* - механизм синхронизации потоков, обеспечивающий доступ к общему ресурсу. В Java реализован с помощью ключевого слова `synchronized`

#### 5. Что такое синхронизация? Какие способы синхронизации существуют в Java?
*Синхронизация* - процесс, позволяющий выполнять потоки параллельно. Способы синхронизации в Java:

- Блок `sychronized` 

```java
public class Counter {

    private int count;

    public synchronized void increment() { //Если много потоков инкрементируют поле у одного объекта
        count++;
    }
```

- `join()` Поток вызвавший этот метод будет ждать до тех пор, пока объект, у которого был вызван этот метод - не закончит свое выполнение

```java
public static void main(String[] args) {
        SimpleThread simpleThread = new SimpleThread();
        simpleThread.start();
        try {
            simpleThread.join(); //До тех пор, пока этот поток не завершит свою работу - мы не пойдем дальше
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(Thread.currentThread().getName());
    } 
```

- Классы из пакета `java.util.concurrent` - **Lock**, **Semaphore**. Концепция данного подхода заключается в использовании атомарных операций и переменных
  
**Semaphore** позволяет задать какое кол-во потоков может получить доступ к ресурсу одновременно

#### 6. Что такое FutureTask?
*FutureTask* — это специальный объект в Java, который выполняет задачу в отдельном потоке и позволяет получить результат этой задачи, когда она завершится. Если задача ещё не закончена, попытка получить результат приостановит (заблокирует) выполнение, пока задача не завершится.

#### 7. Что такое ExecutorService?
Это интерфейс в Java, который помогает управлять потоками более эффективно. Вместо создания новых потоков вручную - можно использовать его для выполнения задач в пулах потоков

#### 8. Как работать с коллекциями в многопоточном программировании?
- Превратить обычную коллекцию - в синхронизированную, с помощью *Collections.synchronized()*
  - `List<String> list = Collections.synchronizedList(new ArrayList<>())`

- Если работа с коллекцией состоит в основном из чтения - *CopyOnWriteArrayList<>()*
  - `List<String> list = new CopyOnWriteArrayList<>()`

- Использование Concurrent-коллекций:
  - Неблокирующие хеш-таблицы (*ConcurrentSkipListMap*, *ConcurrentHashMap*, *ConcurrentSkipListSet*)
  - Неблокирующие очереди (*ConcurrentLinkedQueue* и *ConcurrentLinkedDeque*)

#### 9. SynchronizedCollections. Что это? За счет чего достигается потокобезопасность?
Это специальные коллекции в Java, которые обеспечивают потокобезопасность. Обеспечивается потокобезопасность за счет того, что все методы помечены как `synchronized`

#### 10. CopyOnWriteCollections. Что это? Как происходит запись?
Это потокобезопасные коллекции (*CopyOnWriteArrayList*, *CopyOnWriteArraySet*).
Как происходит запись:
- При добавлении элемента создается новая копия всей коллекции с добавленным изменением
- После завершения операции, оригинальная коллекция заменяется на новую копию, а все другие потоки продолжают работать со старой версией, пока новая не станет доступной

*Стоит использовать, когда в программе много операций чтения*

#### 11. ConcurrentHashMap. Что это? Как происходит запись?
Это потокобезопасная реализация хеш-таблицы.
Как происходит запись:

- *Хеширование ключа.* Сначала вычисляется хеш для ключа, что бы определить, в какой сегмент хеш-таблицы попадет этот элемент
- *Блокировка сегмента.* Блокируется только тот сегмент, в который будет добавлен этот элемент
- *Добавление элемента.* Элемент добавляется - блокировка с сегмента снимается

#### 12. Что такое Deadlock?
Это ситуация, когда два или более потока навсегда блокируются, ожидая ресурсы, которые уже захвачены другими потоками (**Thread A** ожидает **Thread B**, а **Thread B** ожидает **Thread A**)

#### 13. Что такое Livelock?
Несколько потоков попадают в зацикленность при попытке получения каких-либо ресурсов. При этом их состояние постоянно изменяется (Два человека постоянно пытаются уступить друг другу дорогу. Каждый раз когда один делает шаг в сторону, другой делает то же самое)

#### 14. Что такое Race condition?
Это ситуация, при которой результат выполнения программы зависит от порядка выполнения потоков. Возникает, когда несколько потоков одновременно обращаются к разделяемым ресурсам, и результат работы зависит от того, какой поток первым выполнит операции

#### 15. Atomic vs Valotile. Что это и когда что использовать?
**Atomic** — классы (AtomicInteger, AtomicLong, и т.д.), которые предоставляют атомарные операции для работы с примитивами. Они используют внутренние механизмы для обеспечения безопасности при изменении значений без блокировок

**Volatile** — ключевое слово, которое гарантирует, что значение переменной всегда будет читаться из памяти, а не из кэша потока. Каждый поток будет видеть актуальное значение valotile переменной, но если два потока одновременно изменяют переменную, могут возникнуть проблемы

#### 16. Какие бывают состояния у потока?
{{< figure src="Life_Cycle_of_Thread.png" title="Multithreading">}}