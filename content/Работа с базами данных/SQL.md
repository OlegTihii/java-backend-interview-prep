+++
title = 'SQL'
weight = 2
bookFlatSection = true
+++

## SQL

#### 1. Что такое транзакции?
Это набор логически связанных запросов. Транзакция либо выполнится полностью(**commit**), либо откатится(**rollback**)

--- 
#### 2. Расскажите про ACID
Это набор свойств, гарантирующих надежность транзакции:
- **A** - Атомарность. Все операции внутри транзакции либо выполняются полностью, либо не выполняются вообще
- **C** - Согласованность. После выполнения транзакции данные должны соблюдать все правила целостности (правила целостности определяются бизнес-логикой)
- **I** - Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат 
- **D** - Долговечность. Независимо от проблем (потеря питания, сбой и т.д), изменения, сделанные успешно завершенной транзакцией, должны остаться сохранёнными в базе данных    

---
#### 3. Проблемы параллельных транзакций
- *Потерянное обновление*. При одновременном изменении одних и тех же данных разными транзакциями - в силу вступают только изменения в последней транзакции(***Rapeatable read, и все что выше***)
- *Грязное чтение*. Транзакция **A** обновляет значение в базе данных, но еще не закоммитила их. Транзакция **B** считывает это значение, не зная, что изменения могут быть отменены. Если транзакция **A** отменяется, значение, прочитанное транзакцией **B**, было "грязным", так как оно не отражает окончательное состояние базы данных (***Read commited, и всё что выше***)
- *Неповторяющееся чтение*. **Возникает в результате изменения самих данных!** Транзакция **A** читает значение **X** из базы данных. Транзакция **B** обновляет значение **X** и фиксирует изменения. Транзакция **A** повторно читает значение **X**, но теперь оно изменено транзакцией **B** (***Repeatable read и всё что выше***)
- *Фантомное чтение*. **Возникает в результате изменения кол-ва данных!** Транзакция **A** выполняет запрос на выборку всех записей. Транзакция **B** добавляет запись и фиксирует изменения. Транзакция **A** снова выполняет тот же запрос, и теперь результат включает новую запись, которая была добавлена транзакцией **B** (***Serializable***)

---
#### 4. Уровни изолированности (read uncommitted, read committed, repeatable read, serializable)
Перечислил от менее строгого - к самому строгому
- **Read uncommited**. Транзакции могут читать данные, которые еще не зафиксированы другими транзакциями (использовать, когда все транзакции на чтение)
- **Read commited**. Транзакции могут читать только те данные, которые уже зафиксированы другими данными (решает **грязное чтение**)
- **Repeatable read**. В пределах одной транзакции, если вы дважды запрашиваете одну и ту же запись, то независимо от изменений, сделанных другими транзакциями, данные не изменятся. (решает **грязное** и **неповторяющееся чтение** и **потерянное обновление**)
- **Serializable**. Самый строгий уровень изоляции. Транзакции выполняются так, как будто происходят последовательно, одна за другой (**решает всё, но бьет по производительности**)

---
***Какой уровень изолированности стоит по умолчанию в MySQL?***

Repeatable read

---
***Зависимость скорости работы БД и уровня изоляции***

|Уровень изоляции|Описание|Влияние на производительность|
|---|---|---|
|Read Uncommitted|Транзакции могут читать данные, которые ещё не зафиксированы.|Самый быстрый, но данные могут быть неконсистентными.|
|Read Committed|Транзакции читают только зафиксированные данные.|Средняя производительность, баланс между скоростью и консистентностью.|
|Repeatable Read|Гарантирует, что данные, прочитанные транзакцией, не изменятся, пока транзакция не завершена.|Снижает производительность из-за блокировок, но обеспечивает более высокую консистентность.|
|Serializable|Самый высокий уровень изоляции, предотвращает все виды аномалий.|Самый медленный, так как использует полные блокировки.|

---
#### 5. Виды JOIN. Как работает каждый JOIN?
Это такой оператор, позволяющий связать данные из двух таблиц. Бывают:
- *INNER JOIN*. Выдаст общее для левой и правой таблицы
- *LEFT JOIN*. Выдаст все значения с левой таблицы и все подходящие с правой
- *RIGHT JOIN*. Выдаст все значения с правой таблицы и все подходящие с левой
- *FULL JOIN*. Все записи, которые присутствуют в таблицах
- *CROSS JOIN*. Создаст декартово произведение двух таблиц (если в первой таблице 5 строк, а во второй 3, то вернет 5 x 3 = 15)
- *NATURAL JOIN*. Объединяет таблицы по столбцам с одинаковыми именами, если значения в этих столбцах совпадают
- *SELF JOIN*. Соединяет таблицы с самой собой

---
***Как реализовать JOIN?***


**INNER JOIN**

Возвращает только те строки, которые совпадают в обеих таблицах.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Только сотрудники, у которых есть совпадающий отдел.

---

**LEFT JOIN (LEFT OUTER JOIN)**

Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадения нет, то в правых колонках будет `NULL`.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Все сотрудники, даже если они не привязаны к отделу.

---

**RIGHT JOIN (RIGHT OUTER JOIN)**

Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадения нет, то в левых колонках будет `NULL`.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
RIGHT JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Все отделы, даже если в них нет сотрудников.

---

**FULL JOIN (FULL OUTER JOIN)**

Возвращает все строки из обеих таблиц. Если совпадений нет, в соответствующих колонках будет `NULL`.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
FULL JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Все сотрудники и все отделы, включая несвязанные.

---

**CROSS JOIN**

Возвращает декартово произведение таблиц (каждая строка из первой таблицы объединяется с каждой строкой из второй таблицы).

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
CROSS JOIN departments;
```

**Результат:** Все возможные комбинации сотрудников и отделов.

---

**SELF JOIN**

Применяется для объединения таблицы самой с собой.

```sql
SELECT e1.name AS employee1, e2.name AS manager
FROM employees e1
INNER JOIN employees e2 ON e1.manager_id = e2.id;
```

**Результат:** Список сотрудников и их менеджеров.

---
#### 6. Индексы в SQL. Что это? 
Индекс это ключ, построенный из одного или нескольких столбцов в базе данных, который ускоряет выборку. При этом, чем больше дубликатов в столбце - тем хуже работает индекс.

---
***Плюсы и минусы индексов***

**Плюсы:**
- Улучшают производительность для select и сортировки по определенным полям

**Минусы:**
- Ухудшается производительность, когда нужно вставлять, обновлять или удалять данные
- Требуется дополнительное место и чем больше/длиннее ключ - тем больше размер индекса

---
***Какие виды индексов знаешь?***

|Тип индекса|Описание|Использование|
|---|---|---|
|B-дерево (B-tree)|Стандартный индекс, используемый в большинстве СУБД. Данные хранятся в сбалансированном дереве.|Для поиска, сортировки, диапазонных запросов.|
|Индекс с несколькими столбцами (Composite Index)|Индекс, включающий несколько столбцов. Ускоряет запросы, использующие несколько фильтров.|Когда запросы фильтруют по нескольким столбцам одновременно.|
|Индекс полного текста (Full-Text Index)|Индекс для быстрого поиска по тексту, включая ключевые слова и фразы.|Поиск по длинным текстовым полям, например, в статьях или документах.|
|Хеш-индекс (Hash Index)|Использует хеш-функцию для поиска точных совпадений.|Для быстрого поиска по уникальным значениям (например, ID).|
|Индекс с уникальными значениями (Unique Index)|Индекс, обеспечивающий уникальность значений в столбце.|Для обеспечения уникальности значений (например, email).|
|Индекс обратного списка (Bitmap Index)|Индекс с битовыми картами для колонок с малым числом уникальных значений.|Для столбцов с ограниченным числом уникальных значений, например, пол.|
|Инкрементный (Clustered Index)|Индекс, при котором данные таблицы физически упорядочены в соответствии с индексом.|Когда необходимо хранить данные в порядке индекса, например, по ID.|
|Индекс по выражению (Functional Index)|Индекс, основанный на вычисленных значениях или функциях над столбцами.|Для запросов, использующих функции или выражения в фильтрах.|
|Индекс на основе дерева (GiST — Generalized Search Tree)|Общий тип дерева, используемый для индексации сложных типов данных.|Для индексации географических данных или других сложных типов.|
|Индекс на основе префикса (Prefix Index)|Индекс, созданный на части строки, например, на первых символах.|Для текстовых полей, где важно индексировать только часть строки (например, первые несколько символов).|

---
***Почему когда много индексов, это плохо?***

|Проблема|Описание|
|---|---|
|Увеличение времени записи|При вставке, обновлении или удалении данных индексы нужно обновлять, что замедляет операции записи.|
|Большое использование места|Индексы занимают дополнительное место на диске, особенно при большом объеме данных.|
|Сложности с выбором оптимального индекса|СУБД может не выбрать лучший индекс для запроса, если их слишком много.|
|Снижение производительности запросов|Большое количество индексов может привести к дополнительным вычислениям при планировании запроса, что замедляет выполнение.|
|Усложнение управления|Управление большим количеством индексов становится сложным, включая их отслеживание и обслуживание.|
|Избыточность индексов|Некоторые индексы могут быть избыточными, что не только не ускоряет запросы, но и увеличивает нагрузку на систему.|
|Сложности с обслуживанием|Большое количество индексов усложняет операции обслуживания, такие как реорганизация и восстановление.|

---
***Что содержится внутри дерева?***

{{< figure src="B-Tree structure.png" >}}

---
***В индексе ссылка на данные или в самом индексе кешируем данные?***

В индексе хранятся **ссылки** на реальные данные, которые находятся в таблице базы данных. Эти ссылки могут быть представлены в виде:

- **Указателей на строки** в таблице, где хранятся данные.
- **Идентификаторов записей**, которые позволяют найти данные в таблице.

Например, в **B+-дереве**:

- В листьях дерева хранятся не сами данные, а **ссылки на данные** в таблице (или другие индексы).
- Внутренние узлы дерева содержат только **ключи** для направления поиска.

---
***Какие индексы по умолчанию в разных СУБД?***

---
#### 7. Нормализация и денормализация. Перечислите формы
*Нормализация* - процесс преобразования отношений базы данных к виду без избыточной информации. Избыточность - это ситуация, когда одни и те же данные хранятся в базе в нескольких местах. Нормализация проходит через несколько форм:

- **1NF** (1ая нормальная форма). Одна ячейка - одно значение
- **2NF** (2ая нормальная форма). Все не ключевые зависят от ключа
- **3NF** (3ья нормальная форма). Все не ключевые не зависят друг от друга

*Денормализация* - процесс обратный нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. Производительность увеличивается за счет уменьшения сложности запросов

---
#### 8. Что такое внешний ключ?
Ключ, который должен совпадать с ключом другой таблицы

---
#### 9. Чем WHERE отличается от HAVING?
`WHERE` применяется до выполнения агрегатных функций, а `HAVING` - после

---
#### 10. Чем отличается MySQL от PostgreSQL?
**MySQL** — проще, быстрее в базовых операциях, хорош для приложений с высокой нагрузкой на чтение
    
**PostgreSQL** — мощнее, с расширенными функциями и более строгим соблюдением стандартов, лучше подходит для сложных приложений

---
#### 11. Оптимизация запросов. Какие инструменты?
- **EXPLAIN** – Показывает план выполнения запроса, что позволяет увидеть, как СУБД планирует извлекать данные.
- **EXPLAIN ANALYZE** – Выполняет запрос и показывает реальный план выполнения, включая затраченные ресурсы (время, память).
- **Indexes** – Индексы ускоряют доступ к данным, особенно при использовании в условиях WHERE.
- **pg_stat_statements** (для PostgreSQL) – Модуль для сбора статистики выполнения запросов.

---
***SQL-запрос у тебя в норме, но выполнение всё равно долгое. Твои действия?***

- **Использование индексов** – Проверь, правильно ли используются индексы. Возможно, стоит создать или пересмотреть их.
- **Оптимизация плана выполнения** – Используй EXPLAIN и EXPLAIN ANALYZE для анализа плана выполнения запроса и поиска проблемных мест.
- **Рефакторинг запроса** – Перепиши запрос, если есть более эффективный способ получить те же данные. Например, объединение нескольких подзапросов или использование более простых JOIN.
- **Проверка ресурсных ограничений** – Возможно, проблема не в запросе, а в нехватке ресурсов (CPU, память, диск).

---
***EXPLAIN. Что показывает?***

*EXPLAIN* показывает план выполнения запроса до его фактического выполнения. Он выводит, как СУБД собирается получить данные. Это включает:

- Какой тип сканирования будет применяться (Seq Scan, Index Scan).
- Сортировки и объединения (Nested Loop, Hash Join).
- Предполагаемое количество строк и стоимость выполнения на каждом этапе.

---
***Sequence Scan - что означает?***

---
***Explain analyze. Как устроен? На что обращать внимание?***

*EXPLAIN ANALYZE* не только показывает план выполнения, но и выполняет запрос, выводя фактическое время выполнения каждой операции. Полезные моменты:
- **Фактическое время** (Actual Time) – сколько времени заняла операция.
- **ROWS** – реальное количество строк, прошедших через каждый этап.
- **LOOPS** – количество раз, когда этот шаг был выполнен (важно для вложенных циклов).
  
---
#### 12. PostgreSQL. Какой инструмент для сбора статистики?
В PostgreSQL используется встроенный модуль pg_stat_statements для сбора статистики по запросам. Он сохраняет информацию о том, как часто выполняются запросы, какое время они занимают, и сколько ресурсов потребляют.

---
#### 13. PostgreSQL. Какими свойствами обладает из CAP-теоремы?

---
#### 14. Что такое селективность?
*Селективность* – это доля строк, которые будут отобраны запросом из таблицы. Чем меньше строк будет отобрано (меньше доля от общего количества строк), тем более селективен запрос. Высокая селективность обычно означает, что запрос более эффективен, так как обрабатывается меньше данных.

---
#### 15. Ключевое слово LATERAL

---
#### 16. Оконные функции. PARTITION BY	

---
#### 17. cube, rollup, groupBy

---
#### 18. Хранимые процедуры	

---
#### 19. Как работает Serializable?	

---
#### 20. View, materialized view. представлениями, материализованными представлениями?

---	
#### 21. C помощью SQL блокировка строки? - SELECT FOR UPDATE	

---
#### 22. UNION vs UNION ALL	

---
***Что делает UNION?***

---
#### 23  Расскажи про ключевое слово DISTINCT?	

---
#### 24. Что такое табличные выражения?

---
#### 25. Для чего используется Database Connection Pool? (Hikari) Переполнение connection pool	

---
#### 26. Блокировки и локи. Оптимистичная и Пессимистичная
Блокировки (или локи) в базе данных — это механизм, который помогает управлять параллельным доступом к одним и тем же данным, чтобы избежать ошибок и конфликтов. Есть два типа блокировок:
- **Оптимистическая блокировка**. При сохранении данных проверяется, не изменились ли они с момента их чтения. Если изменились — происходит ошибка, и нужно повторить транзакцию.
- **Пессимистическая блокировка**. Означает, что данные блокируются сразу, чтобы другие транзакции не могли их изменить, пока текущая транзакция не завершится.

---
#### 27. БД. Constraint. Какие существуют?	

---
#### 28. Primary Key

---
***Зачем нужен PK?***

---
***PK индексирован?***
