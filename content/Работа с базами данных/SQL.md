## SQL

#### 1. Что такое транзакции?
Это набор логически связанных запросов. Транзакция либо выполнится полностью(**commit**), либо откатится(**rollback**)

#### 2. Расскажите про ACID.
Это набор свойств, гарантирующих надежность транзакции:
- **A** - Атомарность. Все операции внутри транзакции либо выполняются полностью, либо не выполняются вообще
- **C** - Согласованность. После выполнения транзакции данные должны соблюдать все правила целостности (правила целостности определяются бизнес-логикой)
- **I** - Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат 
- **D** - Долговечность. Независимо от проблем (потеря питания, сбой и т.д), изменения, сделанные успешно завершенной транзакцией, должны остаться сохранёнными в базе данных    

#### 3. Проблемы параллельных транзакций.
- *Потерянное обновление*. При одновременном изменении одних и тех же данных разными транзакциями - в силу вступают только изменения в последней транзакции(***Rapeatable read, и все что выше***)
- *Грязное чтение*. Транзакция **A** обновляет значение в базе данных, но еще не закоммитила их. Транзакция **B** считывает это значение, не зная, что изменения могут быть отменены. Если транзакция **A** отменяется, значение, прочитанное транзакцией **B**, было "грязным", так как оно не отражает окончательное состояние базы данных (***Read commited, и всё что выше***)
- *Неповторяющееся чтение*. **Возникает в результате изменения самих данных!** Транзакция **A** читает значение **X** из базы данных. Транзакция **B** обновляет значение **X** и фиксирует изменения. Транзакция **A** повторно читает значение **X**, но теперь оно изменено транзакцией **B** (***Repeatable read и всё что выше***)
- *Фантомное чтение*. **Возникает в результате изменения кол-ва данных!** Транзакция **A** выполняет запрос на выборку всех записей. Транзакция **B** добавляет запись и фиксирует изменения. Транзакция **A** снова выполняет тот же запрос, и теперь результат включает новую запись, которая была добавлена транзакцией **B** (***Serializable***)

#### 4. Уровни изолированности (read uncommitted, read committed, repeatable read, serializable).
Перечислил от менее строгого - к самому строгому
- **Read uncommited**. Транзакции могут читать данные, которые еще не зафиксированы другими транзакциями (использовать, когда все транзакции на чтение)
- **Read commited**. Транзакции могут читать только те данные, которые уже зафиксированы другими данными (решает **грязное чтение**)
- **Repeatable read**. В пределах одной транзакции, если вы дважды запрашиваете одну и ту же запись, то независимо от изменений, сделанных другими транзакциями, данные не изменятся. (решает **грязное** и **неповторяющееся чтение** и **потерянное обновление**)
- **Serializable**. Самый строгий уровень изоляции. Транзакции выполняются так, как будто происходят последовательно, одна за другой (**решает всё, но бьет по производительности**)

#### 5. Какой уровень изолированности стоит по умолчанию в MySQL (Repeatable read)?
Repeatable read

#### 6. JOIN. Какие бывают?
Это такой оператор, позволяющий связать данные из двух таблиц. Бывают:
- *INNER JOIN*. Выдаст общее для левой и правой таблицы
- *LEFT JOIN*. Выдаст все значения с левой таблицы и все подходящие с правой
- *RIGHT JOIN*. Выдаст все значения с правой таблицы и все подходящие с левой
- *FULL JOIN*. Все записи, которые присутствуют в таблицах
- *CROSS JOIN*. Создаст декартово произведение двух таблиц (если в первой таблице 5 строк, а во второй 3, то вернет 5 x 3 = 15)
- *NATURAL JOIN*. Объединяет таблицы по столбцам с одинаковыми именами, если значения в этих столбцах совпадают
- *SELF JOIN*. Соединяет таблицы с самой собой

#### 7. Индексы. Что это? Плюсы и минусы. Какие виды индексов знаешь? Почему когда много индексов, это плохо? Что из себя представляет индекс?
Индекс это ключ, построенный из одного или нескольких столбцов в базе данных, который ускоряет выборку. При этом, чем больше дубликатов в столбце - тем хуже работает индекс.

**Плюсы:**
- Улучшают производительность для select и сортировки по определенным полям

**Минусы:**
- Ухудшается производительность, когда нужно вставлять, обновлять или удалять данные
- Требуется дополнительное место и чем больше/длиннее ключ - тем больше размер индекса

Существует *кластеризованный* и *некластеризованный* индексы.

**Кластеризованный** - хранится вместе с данными (обычно это первичный ключ)

**Некластеризованный** - хранит данные в одном месте, а индексы в другом. По сути - это отдельная таблица, которая ссылается на исходную

#### 8. Нормализация и денормализация. Перечислите формы.
*Нормализация* - процесс преобразования отношений базы данных к виду без избыточной информации. Избыточность - это ситуация, когда одни и те же данные хранятся в базе в нескольких местах. Нормализация проходит через несколько форм:

- **1NF** (1ая нормальная форма). Одна ячейка - одно значение
- **2NF** (2ая нормальная форма). Все не ключевые зависят от ключа
- **3NF** (3ья нормальная форма). Все не ключевые не зависят друг от друга

*Денормализация* - процесс обратный нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. Производительность увеличивается за счет уменьшения сложности запросов

#### 9. Что такое внешний ключ?
Ключ, который должен совпадать с ключом другой таблицы

#### 10. Чем WHERE отличается от HAVING?
`WHERE` применяется до выполнения агрегатных функций, а `HAVING` - после

#### 11. Чем отличается MySQL от PostgreSQL?
**MySQL** — проще, быстрее в базовых операциях, хорош для приложений с высокой нагрузкой на чтение
    
**PostgreSQL** — мощнее, с расширенными функциями и более строгим соблюдением стандартов, лучше подходит для сложных приложений

#### 12. Оптимизация запросов. Какие инструменты?
- **EXPLAIN** – Показывает план выполнения запроса, что позволяет увидеть, как СУБД планирует извлекать данные.
- **EXPLAIN ANALYZE** – Выполняет запрос и показывает реальный план выполнения, включая затраченные ресурсы (время, память).
- **Indexes** – Индексы ускоряют доступ к данным, особенно при использовании в условиях WHERE.
- **pg_stat_statements** (для PostgreSQL) – Модуль для сбора статистики выполнения запросов.

#### 13. SQL-запрос у тебя в норме, но выполнение всё равно долгое. Твои действия?
- **Использование индексов** – Проверь, правильно ли используются индексы. Возможно, стоит создать или пересмотреть их.
- **Оптимизация плана выполнения** – Используй EXPLAIN и EXPLAIN ANALYZE для анализа плана выполнения запроса и поиска проблемных мест.
- **Рефакторинг запроса** – Перепиши запрос, если есть более эффективный способ получить те же данные. Например, объединение нескольких подзапросов или использование более простых JOIN.
- **Проверка ресурсных ограничений** – Возможно, проблема не в запросе, а в нехватке ресурсов (CPU, память, диск).

#### 14. Пользовался Explain? Что показывает?
*EXPLAIN* показывает план выполнения запроса до его фактического выполнения. Он выводит, как СУБД собирается получить данные. Это включает:

- Какой тип сканирования будет применяться (Seq Scan, Index Scan).
- Сортировки и объединения (Nested Loop, Hash Join).
- Предполагаемое количество строк и стоимость выполнения на каждом этапе.

#### 15. Explain analyze. Как устроен? На что обращать внимание?
*EXPLAIN ANALYZE* не только показывает план выполнения, но и выполняет запрос, выводя фактическое время выполнения каждой операции. Полезные моменты:
- **Фактическое время** (Actual Time) – сколько времени заняла операция.
- **ROWS** – реальное количество строк, прошедших через каждый этап.
- **LOOPS** – количество раз, когда этот шаг был выполнен (важно для вложенных циклов).

#### 16. PostgreSQL. Какой инструмент для сбора статистики?
В PostgreSQL используется встроенный модуль pg_stat_statements для сбора статистики по запросам. Он сохраняет информацию о том, как часто выполняются запросы, какое время они занимают, и сколько ресурсов потребляют.

#### 17. PostgreSQL. Какими свойствами обладает из CAP-теоремы?
-

#### 18. Что такое селективность?
*Селективность* – это доля строк, которые будут отобраны запросом из таблицы. Чем меньше строк будет отобрано (меньше доля от общего количества строк), тем более селективен запрос. Высокая селективность обычно означает, что запрос более эффективен, так как обрабатывается меньше данных.

#### 19. Ключевое слово LATERAL.
-
