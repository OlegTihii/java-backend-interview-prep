+++
title = 'ORM'
weight = 4
bookFlatSection = true
+++

## ORM

#### 1. Что такое Hibernate, JPA, JDBC, ORM?
*Hibernate* - это ORM Framework (один из самых распространённых JPA реализаций) 

*JPA* - это спецификация Java, которая предоставляет набор интерфейсов/аннотаций

*ORM* - процесс преобразования объектно-ориентированной модели в реляционную и наоборот

*JDBC* - низкоуровневый API для взаимодействия с базами данных. 

---
#### 2. Плюсы и минусы ORM.
**Плюсы:**
- Позволяет бизнес методам обращаться не к БД, а к Java классам
- Ускоряет разработку приложения
- Основан на JDBC
- Сущности основаны на бизнес-задачах, а не на струкруре БД
- Управление транзакциями

**Минусы:**
- **Потенциальная потеря производительности** — автоматическая генерация SQL-запросов может быть менее оптимальной, чем ручное написание запросов.
- **Сложные запросы** — ORM плохо справляется с очень сложными SQL-запросами, такими как сложные агрегатные функции или многоуровневые JOIN'ы.

---
#### 3. Как создать Entity и что это такое?
Это класс, помеченный аннотацией `@Entity`, нужен для маппинга Java объектов в БД объекты и наоборот. Она должна соответствовать следующим условиями:

- Должен иметь пустой конструктор
- Не может быть вложенным, интерфейсом, ENUM, или final
- Не может содержать final полей
- Хотя бы одно поле помеченное аннотацией `@Id `
- Аннотация `@Entity` над классом
- Должен быть `POJO` (все поля private + getter-ы и setter-s к ним)

---
#### 4. Может ли наследоваться от не-Entity классов?
Да. Может

---
#### 5. Может ли наследоваться от других Entity классов?
Да. Может

---
#### 6. Почему мы не можем использовать final классы в качестве Entity?
Превращение Entity в final ограничивает способность Hibernate использовать прокси, что в свою очередь, не позволяет Hibernate применять ленивую загрузку. Потому что, прокси-класс должен наследоваться от класса-сущности, чтобы заменить его настоящим объектом при необходимости, но т.к final запрещает наследование от классов - мы этого сделать не можем

---
#### 7. Что такое Proxy и для чего используется?
**Hibernate Proxy** — это объект-заместитель (placeholder) для реального объекта, который загружается "лениво" (lazy loading). Это значит, что Hibernate создает прокси-объект вместо настоящего объекта из базы данных, и реальные данные загружаются только при первом доступе к ним. Это помогает оптимизировать производительность, загружая данные только тогда, когда они действительно нужны.

---
***В какой момент создается Proxy?***

---
***Виды прокси***


---
#### 8. FetchType.
*LAZY* - данные поля будут загружены не сразу, а только при обращении к ним

*EAGER* - связанные сущности загружаются сразу вместе с основной сущностью

- `@OneToMany` `@ManyToMany` - по-умолчанию применяется FetchType.LAZY
- `@ManyToOne` `@OneToOne` - по-умолчанию применяется FetchType.EAGER

---
#### 9. Жизненный цикл сущности.
В Hibernate сущность может находиться в одном из четырех состояний:
{{< figure src="Hibernate_Entity_Life_cycle.png" >}}

- **Transient (Переходное состояние) (new)**
  
Сущность только что создана с помощью оператора new, но еще не сохранена в базе данных

```java
User user = new User(); // объект пока не связан с БД
user.setName("John"); 
```

- **Persistent (Постоянное состояние) (save,persist,update,get)**

Когда объект сохранен в базе данных через EntityManager или Session, он становится постоянным. В этом состоянии Hibernate следит за объектом. Любые изменения в объекте автоматически синхронизируются с базой данных

```java
Session session = sessionFactory.openSession();
session.beginTransaction();
session.save(user); // объект теперь в состоянии persistent
```

- **Detached (Отсоединённое состояние) (session close)**

Когда сессия закрыта, объект переходит в состояние detached. Он по-прежнему связан с данными в базе, но больше не синхронизируются с ней

```java
session.close(); //  объект можно использовать, но изменения не будут сохранены в бд
```
- **Removed (Удалённое состояние)  (delete(obj))**

Когда сущность удалена из базы данных она переходит в состояние removed. В этом состоянии объект по-прежнему существует в памяти, но уже удален из базы данных

```java
session.delete(); 
```

---
#### 10. Кеширование.
- Кэш **1-го** уровня
  - Этот кэш всегда включен и работает на уровне сессии (у каждой сессии свой кэш и нельзя получить доступ к нему из другой сессии)
  - В кэше хранятся только сущности, у которых состояние `persistent`
  - Отслеживаемые сущности (`persistent`) хранятся в мапе, где ключ - ID сущности, а значение - сами объекты-сущности
  - При повторных запросах Hibernate использует кэшированные данные вместо выполнения нового запроса к базе данных
  - При закрытии сессии - кэш удаляется

- Кэш **2-го** уровня
  - Это дополнительный кэш, который надо включать вручную
  - Работает на уровне `SessionFactory` 
  - Используется для кэширования данных между сессиями, что позволяет повторно использовать данные, уже загруженные из базы данных
  - После закрытия `SessionFactory` - весь кэш, связанный с ним, умирает

- Кэш **3-го** уровня
  - Кэширует результаты запросов на уровне SQL-запросов (кэширует результаты выборки)

---
#### 11. HQL и JPQL.
Являются объектно-ориентированными языками запросов, схожими по природе с SQL

*HQL* полностью объектно-ориентирован и расширяет JPQL

*JPQL* - это стандарт JPA, который поддерживается всеми реализациями JPA, а HQL - реализация Hibernate

---
#### 12. EntityManager + EntityManagerFactory / SessionFactory + session.
Разница в том, где они используются. 

EntityManager и EntityManagerFactory - это *JPA*.

Session и SessionFactory - *Hibernate*. 

Session - основной интерфейс для взаимодействия с базой данных в Hibernate. Создается из SessionFactory 

---
#### 13. Проблема N + 1.
Это проблема, которая возникает, когда приложение делает слишком много запросов к базе данных, когда можно обойтись одним.

**Пример:**

Представь, что у тебя есть две связанные сущности: User (пользователь) и Order (заказ). Каждый пользователь может иметь много заказов.

Допустим, ты хочешь получить список всех пользователей и их заказов. Проблема N+1 возникает, когда вместо одного запроса к базе данных для получения всех пользователей и их заказов приложение сначала делает 1 запрос, чтобы получить всех пользователей, а затем делает N дополнительных запросов — по одному для каждого пользователя, чтобы получить его заказы

```java
@Entity
public class User {
    @Id
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders;
}

@Entity
public class Order {
    @Id
    private Long id;

    private String item;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

---
**Как избежать проблемы N + 1**
- JOIN FETCH. Это способ сказать Hibernate загрузить связанные данные вместе с основными (типа обычного JOIN-а)

```java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllUsersWithOrders();
```

- Использовать `FetchType.EAGER` вместо `FetchType.LAZY`
- Использовать EntityGraph. Указываем, какие данные загружать в конкретных запросах, не изменяя сущности (как в случае с жадной загрузкой)

```java
@EntityGraph(attributePaths = {"orders"})
List<User> findAll();
```

---
#### 14. Что такое Entity Graph?
*Entity Graph* — это механизм в JPA, который позволяет управлять стратегией загрузки данных, определяя, какие связанные сущности должны быть загружены сразу (eager) или отложенно (lazy). Это дает гибкость в выборе полей для загрузки в зависимости от запроса.

---
***Как создать?***

Создается аннотацией `@NamedEntityGraph` на уровне сущности или динамически через API.

---
***Что под капотом?***

Entity Graphы работают на уровне SQL-запросов, добавляя нужные JOIN-ы и выбирая необходимые поля.

---
***Как им пользоваться?***

**Использование имени графа:**

```java
EntityManager entityManager = ...;

Map<String, Object> properties = new HashMap<>();
properties.put("javax.persistence.loadgraph", entityManager.getEntityGraph("User.withRoles"));

User user = entityManager.find(User.class, 1L, properties);

```

**Использование динамического графа:**

```java
EntityManager entityManager = ...;

EntityGraph<User> entityGraph = entityManager.createEntityGraph(User.class);
entityGraph.addAttributeNodes("roles");

Map<String, Object> properties = new HashMap<>();
properties.put("javax.persistence.loadgraph", entityGraph);

User user = entityManager.find(User.class, 1L, properties);

```

**Использование в Spring Data JPA:**

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @EntityGraph(attributePaths = {"roles"})
    User findByName(String name);
}

```

---
#### 15. Statement, Prepared statement, Callable statement.
- *Statement* - объект, который используется для формирования простых SQL запросов. Уязвим к SQL инъекциям

- *PreparedStatement*
  - Добавляет возможность динамической вставки входных параметров
  - Предотвращает SQL инъекции
  - Быстрее чем Statement, потому что использует кэширование

- *CallableStatement* - для вызова хранимых процедур

---

#### 16. Связи между таблицами в ORM?
  1. OneToOne
  2. OneToMany, ManyToOne
  3. ManyToMany

---
***Как реализована связь ManyToMany?***

Для реализации такого вида связи создается промежуточная таблица для хранения идентификаторов обеих сущностей
*Пример*: Учителя могут преподавать несколько предметов, каждый предмет может преподаваться несколькими преподавателями

```java
@Entity
public class Student {
    @Id @GeneratedValue
    private Long id;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
}

@Entity
public class Course {
    @Id @GeneratedValue
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}

```

---
***Как реализована связь OneToMany?***

Одному объекту одной сущности соответствует множество объектов другой сущности.

```java
@Entity
public class Department {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
    private List<Employee> employees;
}

@Entity
public class Employee {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    private Department department;
}

```

---
***Как реализована связь ManyToOne?***

Множеству объектов одной сущности соответствует один объект другой сущности.

```java
@Entity
public class Employee {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}

@Entity
public class Department {
    @Id @GeneratedValue
    private Long id;
}

```

---
***В чем отличия между связями?***

|Тип связи|Суть|Пример отношений|Особенности|Реализация в базе данных|
|---|---|---|---|---|
|**OneToOne**|Один к одному|Паспорт и владелец|Каждая сущность связана с одной другой сущностью|Один из объектов содержит внешний ключ|
|**OneToMany**|Один ко многим|Департамент и сотрудники|Один объект связан с несколькими объектами другой сущности|Один внешний ключ на стороне "многих"|
|**ManyToOne**|Многие к одному|Сотрудники и департамент|Обратное отношение к `OneToMany`|Внешний ключ на стороне "многих"|
|**ManyToMany**|Многие ко многим|Студенты и курсы|Множеству объектов одной сущности соответствует множество другой|Промежуточная таблица|

---
***OneToMany: разница между List и Set.***

|Характеристика|`List`|`Set`|
|---|---|---|
|**Уникальность**|Допускает дубликаты|Гарантирует уникальность элементов|
|**Порядок**|Сохраняет порядок добавления|Не гарантирует порядок|
|**Производительность**|Медленнее при проверке наличия|Быстрее при проверке наличия|
|**Используемая реализация**|`ArrayList` или `LinkedList`|Обычно `HashSet` или `TreeSet`|

---
#### 17. LazyInitializationException.
Это происходит, когда объект был загружен с ленивой загрузкой, но его данные пытаются быть использованы после закрытия сессии

```java
public void printAuthorBooks(Long authorId) {
    Session session = sessionFactory.openSession();
    Author author = session.get(Author.class, authorId);
    session.close();
    
    // Попытка доступа к ленивой коллекции после закрытия сессии
    System.out.println(author.getBooks());  // Может вызвать LazyInitializationException
}
```

- Как решить?
  - JOIN FETCH. Это способ сказать Hibernate загрузить связанные данные вместе с основными (типа обычного JOIN-а)
  - Использовать EntityGraph. Указываем, какие данные загружать в конкретных запросах, не изменяя сущности (как в случае с жадной загрузкой) 

---
#### 18. Что такое SQL-инъекция?
Это тип уязвимости, которая позволяет злоумышленникам вмешиваться в запросы к базе данных, чтобы выполнить вредоносные команды

```sql
SELECT * FROM users WHERE username = 'user' OR '1'='1' AND password = 'password';
```

- Последствия SQL инъекций:
  - Войдет в систему обходя проверку логина и пароля
  - Возможность удалить важные данные из БД
  - Возможность изменить данные в БД
  - Доступ к конфиденциальной информации

- Как избежать:
  - Использовать PreparedStatement
  - Использовать Hibernate

---
#### 19. Проблемы JOIN FETCH.
- Проблема
  - Дублирование данных. При загрузке основной сущности с её связанными сущностями результаты могут содержать дубликаты

- Решение
  - Использовать DISTINCT, чтобы избежать дубликатов 
   ```sql
   SELECT DISTINCT o FROM Order o JOIN FETCH o.items
   ```
  - Использование Set для хранения связных элементов

---
#### 20. Логи в Hibernate.
Hibernate предоставляет детализированные логи через категорию `org.hibernate.SQL`. Это помогает отслеживать сгенерированные SQL-запросы, параметры и выполнение транзакций. Включение логов может помочь отладить проблемы с производительностью или запросами, но может замедлить выполнение при большом количестве запросов.

```java
log4j.logger.org.hibernate.SQL=DEBUG
log4j.logger.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

---
#### 21. Query. Что это такое?

---
#### 22. Какие инструменты использует Hibernate для написание запросов?

---
#### 23. Hibernate. Что хранится в Persistence Context? Сколько времени объект хранится в Psersistence Context?