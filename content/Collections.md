## Collections

> **Обязательно к прочтению**
> - ArrayList - https://habr.com/ru/articles/128269/ 
> - LinkedList - https://habr.com/ru/articles/127864/
> - HashMap - https://habr.com/ru/articles/128017/

#### 1. Расскажите как выглядит иерархия коллекций
{{< figure src="Collections.png" title="Collections">}}

**Collection** и **Map** - два интерфейса, которые находятся на вершине иерархии JCF. Интерфейс Collection расширяют интерфейсы:
- List
- Queue
- Set

#### 2. Что такое ArrayList?
  Это список, реализованный на основе динамически расширяемого массива. То есть под капотом буквально создается массив

#### 3. Какая размерность массива(который под капотом) если создавать через конструктор без параметров?
Capacity = 10

#### 4. Можно ли задать начальную емкость списка?
Да, через конструктор (`List<String> list = new ArrayList<String>(15)`)

#### 5. Расскажите, что происходит под капотом при добавлении элемента в конец списка
Проверяется достаточно ли места для добавления нового элемента. Если достаточно, то он просто добавляется в конец. Иначе:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

#### 6. Расскажите, что происходит под капотом при добавлении элемента в середину списка
Проверяется, достаточно ли места при добавлении нового элемента. Если достаточно - все элементы сдвигаются на один вправо. Если места недостаточно - происходит:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

#### 7. Какая скорость добавления элемента в начало списка?
 Начало списка: **О(n)**

#### 8. Какая скорость добавления элемента в середину списка?
 Середину списка: **О(n)**

#### 9. Какая скорость добавления элемента в конец списка?
  Конец списка: **О(1)**

#### 10. Какая скорость доступа по индексу?
  **О(1)**

#### 11. Какая скорость удаления элемента в начале списка?
  Начало списка: **О(n)**

#### 12. Какая скорость удаления элемента в середине списка?
  Середина списка: **О(n)**

#### 13. Какая скорость удаления элемента с конца списка?
  Конец списка: **О(1)**

#### 14. Какая скорость доступа к элементам по значению?
  **О(n)** (т.к нужно итерироваться по всему списку пока не найдем нужное значение)

#### 15. Что такое LinkedList?
Классический двусвязный список, основанный на объектах с ссылками между ними. Реализует интерфейсы List и Deque. Данные хранятся в объектах типа Nod-ах

#### 16. Расскажите как работает добавление под капотом?
При создании LinkedList-а, у нас создается псевдо элемент - `Header` в котором хранятся next и prev, которые пока указывают сами на себя. После добавления элемента, ссылки next и prev у каждого объекта будут указывать на предыдущий и следующий.

#### 17. Сколько занимает добавление в начало списка?
  Начало списка: **О(1)**

#### 18. Сколько занимает добавление в середину списка?
  Середину списка: **О(n)**

#### 19. Сколько занимает добавление в конец списка?
  Конец списка: **О(1)**

#### 20. Сколько занимает удаление с начала списка?
  Начала списка: **О(1)**

#### 21. Сколько занимает удаление в середине списка?
  Середину списка: **О(n)**

#### 22. Сколько занимает удаление с конца списка?
  Конец списка: **О(1)**

#### 23. Сколько занимает чтение со списка по индексу?
  С начала и конца: **О(1)** (т.к есть доступ к первому и последнему элементу)

  С середины: **О(n)**

#### 24. Что такое TreeMap?
Класс в Java, который реализует интерфейс `NavigableMap`, который в свою очередь наследуется от `SortedMap`. Представляет собой ассоциативный массив, где ключи отсортированы в их естественным порядком
Единственная коллекция, которая **не использует** `equeals()` и `hashCode()` 
Основана на красно-черных деревьях

#### 25. Какая скорость операций у TreeMap?
**О(log n)** (т.к каждый раз отметается половина)

#### 26. Устройство TreeMap
Древовидная структура: под капотом TreeMap использует структуру данных, которая называется **красно-чёрное дерево**.

#### 27. Что такое HashMap?
Ассоциативный массив, хранит пары "ключ-значение". Ключ-уникальный, значение-может повторяться. Каждая ячейка массива - бакет(корзина), хранящий в себе односвязный список узлов. Если у односвязного списка node больше 8 элементов (коллизии), он превращается в красно-чёрное дерево, обратно - если количество элементов в бакете уменьшилось до 6. Может содержать один ключ null и любое количество значений null. Не отсортирован и не упорядочен

#### 28. Почему строка является популярным ключом в HashMap?
1. Иммутабельность (неизменяемость)
2. Хорошая реализация методов `hashCode()` и `equals()`
  

#### 29. Сколько изначально бакетов создается?
  По умолчанию - **16**

#### 30. В каком случае количество бакетов увеличивается?
Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

#### 31. Какая скорость операций?
  **О(1)**. Благодаря хеш-коду

#### 32. Опишите, как проходит процесс добавления объекта?
1. Вычисляется хеш-код ключ, на основании которого вычисляется бакет, в который будет добавлен новый элемент
2. Если бакет пустой - просто добавляем элемент
3. Если нет - идем по списку и сравниваем ключ добавляемого элемента и ключ элемента в списке по хеш-кодам
4. Если хеш-коды не равны - идем к следующему элементу
5. Если равны - сравниваем по `equals()`
6. Если ключи равны по `equals()` - перезаписываем value по этому ключу
7. Если ключи не равны по `equals()` - переходим к следующему элементу
8. Если мы не нашли ключ в списке, то добавляем этот элемент в конец списка
9. Так до тех пор, пока новое значение не перезапишет некоторое старое, или не достигнет конца односвязного списка и сохранится там последним элементом

#### 33. Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет своим преимущества

#### 34. Почему предпочтительно использовать в качестве ключа immutable объект?
Потому что, если изменить объект на котором основан ключ, то у него поменяется хеш-код ⇒ найти элемент в HashMap-е не получится. Именно поэтому предпочтительно использовать immutable объекты (например String)

#### 35. Что такое HashSet?
HashSet — коллекция, не содержащая в себе дубликатов

#### 36. Как HashSet связан с HashMap?
HashSet использует HashMap для хранения элементов

#### 37. Сколько изначально бакетов создается в HashSet?
  По умолчанию - **16**

#### 38. В каком случае количество бакетов в HashSet увеличивается?
Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

#### 39. Какая скорость операций?
  **О(1)**. Благодаря хеш-коду

#### 40. Как проходит процесс добавления элемента в HashSet?
1. Получаем hashCode объекта, который мы помещаем в hashSet
2. Определяем в какой бакет класть объект (остаток от деления хеш-кода на кол-во бакетов)
3. Проверяется, существует ли уже элемент в бакете
4. Если нет - то элемент добавляется в бакет. Если есть - добавление игнорируется, т.к HashSet не допускает дубликатов

>P.S. Перед добавлением элемента - проверка. Если кол-во элементов == кол-ву бакетов - количество бакетов увеличивается на х2

#### 41. Будет ли работать HashSet, если все добавляемые элементы будут иметь одинаковый hashCode()?
Да, будет, но его производительность ухудшится. Если все элементы имеют одинаковый хеш-код, они все будут размещены в одном бакете, что приведет к увеличению времени поиска

#### 42. Что такое Queue?
Queue - это интерфейс в Java, который представляет собой коллекцию элементов, работающую по принципу "первый вошел — первый вышел" (**FIFO** — First In, First Out). 

#### 43. Какая скорость операций?
  **О(1)**

#### 44. Назовите главные реализации Queue?
1. LinkedList
2. ArrayDeque

#### 45. Что такое Deque?
Deque (Double-Ended Queue) — это интерфейс в Java, который представляет собой очередь с двумя концами. Это означает, что элементы могут быть добавлены или удалены как с начала, так и с конца очереди. Таким образом, Deque может работать как очередь (**FIFO**) и как стек (**LIFO**).

#### 46. Назовите главные реализации Deque?
1. LinkedList
2. ArrayDeque (Double ended queue)

#### 47. Какая скорость операций Deque?
  **О(1)**

#### 48. Какая коллекция реализует дисциплину обслуживания LIFO?
- Deque

