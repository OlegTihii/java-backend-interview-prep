## Spring

#### 1. Зачем мы используем Spring? Почему его так любят?
*Spring* — это один из самых популярных фреймворков для разработки приложений на Java. Его используют благодаря широкому набору возможностей, гибкости и модульности, что упрощает разработку корпоративных приложений.

#### 2. Inversion of Control.
Это принцип, при котором мы передаем управление созданием и настройкой объектов Spring-у

#### 3. Dependency Injection.
Это реализация IoC, посредством которой созданием объекта и внедрением его зависимостей занимается фреймворк.

#### 4. Какие способы внедрения зависимостей знаешь? Почему лучше использовать конструктор?
Существует три способа внедрения зависимостей:
- Через конструктор
- Через сеттер 
- Через аннотацию `@Autowired`

**Почему лучше использовать конструктор?**

Облегчает тестируемость. При использовании конструктора тестировать код проще, так как можно передавать зависимости явно, создавая тестовые объекты без использования Spring-контейнера.

#### 5. @Autowired.
Автоматически внедряет бины. Аннотацией `@Autowired` помечают:
- Сеттер
- Поле
- Конструктор

#### 6. @Qualifier vs @Primary.
Если есть два одинаковых бина (по типу и имени) Spring не знает какой именно использовать и выдает *exception*. Если над одним из этих бинов установлена `@Primary`, то его использовать предпочтительнее. Но если нам нужно использовать в работе оба этих бина, можно над каждым поставить `@Qualifier` и задать имя, для идентификации этих бинов (работает только с `@Autowired`)

#### 7. @Bean.
Аннотация `@Bean` используется для указания метода, который возвращает объект(бин) и эти бины в дальнейшем можно внедрять в другие компоненты.

#### 8. @ComponentScan.
Аннотация `@ComponentScan` указывает Spring где искать классы, помеченные аннотацией `@Component` или его производной (`@RestController`, `@Controller`, `@Repository`, `@Service` и т.д)

#### 9. @Conditional в Spring.
Аннотация `@Conditional` в Spring используется для того, чтобы условно подключать бины или выполнять конфигурации только при соблюдении определённых условий. Она позволяет гибко управлять поведением приложения, включая или исключая определенные компоненты на основе внешних или внутренних условий.

#### 10. @Service, @Repository, @Component.
- `@Service` - То же, что и `@Component`. Говорит, что класс является бизнес логикой
- `@Repository` - Помечает класс-репозиторий
- `@Component` - Делает класс Spring бином для автоматического создания и использования

#### 11. @Controller и @RestController.
- `@Controller` В основном используется для возврата веб-страниц. Если нужно вернуть данные (например, JSON), нужно добавить `@ResponseBody` к методу
- `@RestContoller` Это комбинация `@Controller` и `@ResponseBody`. Используется в REST.
Всегда возвращает данные (например, JSON или XML) в теле HTTP-ответа.
Нет необходимости добавлять `@ResponseBody` к каждому методу.

#### 12. @ResponseBody vs ResponseEntity.
- *ResponseEntity* — это объект, который содержит как тело ответа, так и HTTP-статус (например, 200 OK, 404 Not Found) и заголовки. Используется для более гибкого управления HTTP-ответами
- `@ResponseBody` Аннотация, которая указывает, что результат метода контроллера должен быть возвращен как тело HTTP-ответа (например, JSON, XML)

#### 13. Скоуп бинов.
- Singleton
  - Для каждого бина создается только один экземпляр на весь контекст приложения и переиспользуется везде, где он требуется
  - Используется по-умолчанию
  - Жизненный цикл бина начинается при загрузке контекста, и заканчивается при его завершении

- Prototype
  - Каждый раз, когда запрашивается бин, создается новый экземпляр
  - Бины со скоупом `prototype` не уничтожаются Spring, так как они выходят из его контроля сразу после создания
  - **НЕ ХРАНЯТСЯ** в контексте Spring-а

Так же есть 
- Session - один объект на каждый HTTP-сессию.
- Request -  новый объект на каждый HTTP-запрос.
- Application - один объект на протяжении времени работы сервера
- WebSocket - один объект на WebSocket-сессию

#### 14. Как конфигурируется бин?
- Конфигурация через аннотацию `@Bean`
- Автоматическая конфигурация через аннотацию `@Component`
- Конфигурация через XML

#### 15. Жизненный цикл бина.
{{< figure src="Spring_Bean_Life_cycle_Flow.png" >}}

- Сначала мы предоставляем наши Bean Definitions IoC контейнеру 
- IoC-контейнер сортирует Bean Definitions чтобы сначала создавать те, которые не имеют зависимостей, и затем те, которые зависят от других бинов
- Затем итерируется по всем Bean Definitions и инициализирует их 
- Далее вызываются PostConstruct методы
- Перед и после инициализации вызываются методы BeanPostProcessor
- На выходе получаем готовый бин. Если у этого бина скоуп singleton - храним его в ассоциативном массиве IoC контейнера. Если же другой скоуп - бин сразу же возвращается
- Для всех бинов, которые находятся в IoC контейнере, перед его завершением вызывается `@PreDestroy` метод 

#### 16. Spring MVC. Что это? Какие проблемы решает?
Spring MVC — это один из модулей Spring Framework, предназначенный для разработки веб-приложений на основе шаблона Model-View-Controller. Решает следующие проблемы

- Чёткое разделение логики. Разбиваем логику на MVC
- Поддержка различных шаблонизаторов. JSP, Thymeleaf и т.д
- Упрощает обработку HTTP-запросов через контроллеры

#### 17. Парадигма AOP.
*AOP* - это способ добавить в программу дополнительные функции, не трогая основной код программы.
Например, у нас есть метод, который что-то делает. Но нам нужно, чтобы перед началом и в конце работы этого метода писался лог. Вместо того чтобы добавлять этот код логирования в каждый метод руками - можно вынести его в отдельное место (аспект), а Spring сам "вставит" его туда, где нужно, без изменений основного кода.

#### 18. Циклическая зависимость.
Циклическая зависимость - это когда два класса взаимно ссылаются друг на друга через аннотацию `@Autowired`. Это может вызвать проблему циклической зависимости, которую Spring Framework не сможет разрешить. Для решения этой проблемы можно использовать один из следующих подходов:

- Внедрять зависимости через set-ер
- Использование `@Lazy`. Аннотация `@Lazy` откладывает создание бина до момента его использования, что позволяет разорвать круг

```java
@Component
public class BeanA {
    private final BeanB beanB;

    @Autowired
    public BeanA(@Lazy BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {
    private final BeanA beanA;

    @Autowired
    public BeanB(@Lazy BeanA beanA) {
        this.beanA = beanA;
    }
}
```

#### 19. Spring Boot. Что это? Какие проблемы решает? Чем отличается от Spring?
*Spring Boot* — это фреймворк на основе Spring, который позволяет быстрее и проще создавать готовые к работе приложения. Ключевые преимущества:

- Стартеры — это готовые наборы библиотек (модулей), которые включают все необходимые зависимости для работы с конкретными технологиями
- Встроенный сервер - В Spring Boot сервер **встроен прямо в приложение**. Например, когда вы добавляете стартер `spring-boot-starter-web`, Spring Boot автоматически включает Tomcat или Jetty
- Автоматическая конфигурация - Spring Boot использует механизм **автоматической конфигурации**, который анализирует, какие библиотеки находятся в вашем проекте, и автоматически настраивает необходимые компоненты.
- Упрощение сборки - В обычном Spring для развертывания приложения вам нужно собрать WAR файл и развернуть его на сервере. В Spring Boot приложение собирается в **исполняемый JAR файл**, который содержит все зависимости и сервер.

#### 20. Spring JDBC.
*Spring JDBC* — это модуль Spring, который упрощает взаимодействие с базами данных, используя JDBC (Java Database Connectivity). Он предлагает упрощённый подход к выполнению SQL-запросов, обработке результатов и управлению ресурсами.

#### 21. Spring Data JPA.
*Spring Data JPA* — это модуль Spring, который упрощает работу с JPA (Java Persistence API) и предоставляет удобные способы доступа к данным. Он позволяет разработчикам сосредоточиться на бизнес-логике, не заботясь о низкоуровневых деталях доступа к данным.

#### 22. Блокировка по умолчанию в Spring.
В Spring, по умолчанию, используется **оптимистичная блокировка** для управления конкурентным доступом к данным. Это означает, что при обновлении сущностей предполагается, что конфликты не произойдут, и изменения вносятся в базу данных без блокировок.

#### 23. @Transactional. Как работает?
`@Transactional` — это аннотация, которая позволяет автоматически управлять транзакциями. Когда метод аннотирован `@Transactional`, Spring берет на себя начало, коммит или откат транзакции

#### 24. Что можно пометить аннотацией @Transactional?
- Класс. Все его методы станут `@Transactional` 
- Метод

#### 25. Дефолтный propagation.
Propagation.REQUIRED

#### 26. Какие способы управления транзакциями в Spring вы знаете?
- Аннотация `@Transactional`
- TransactionManager
- TransactionTemplate

#### 27. Где и какой способ использовать?
*TransactionManager* и *TransactionTemplate*

- Когда требуется точный контроль над транзакциями (например, управлять несколькими транзакциями в одном потоке)

*@Transactional*

- Когда нужно простое управление транзакциями
- Когда транзакция не требует сложной логики управления

#### 28. Атрибут propagation у @Transactional.
- **REQUIRED** — применяется по умолчанию. При входе в `@Transactional` метод будет использована уже существующая транзакция или создана новая транзакция, если никакой еще нет
- **REQUIRES_NEW** — для внутреннего метода создается своя отдельная транзакция. Пока выполняется внутренний метод, внешняя транзакция приостанавливается. Результат выполнения внутренней - не повлияет на результат выполнения внешней
- **NESTED** — создаёт под транзакцию внутри основной транзакции. Эта под транзакция может быть откатана отдельно от основной, но зависит от успешного завершения основной транзакции. Если основная транзакция откатится, под транзакция тоже откатится, даже если она завершилась успешно
- **MANDATORY** — требует внешнюю транзакцию, а иначе выбрасывается исключение
- **SUPPORTS** — метод будет выполняться в рамках транзакции, если она существует. Если ее нет, метод выполнится без транзакции
- **NOT_SUPPORTED** — метод всегда выполняется вне транзакции, даже если существует текущая транзакция. Текущая транзакция приостанавливается
- **NEVER** — запрещает выполнение метода в транзакции

#### 29. Какие еще есть атрибуты у @Transactional?
- **Isolation**. Задает уровень изолированности для транзакции (default - уровень изоляции по-умолчанию БД)
- **TimeOut**. Задаёт время ожидания транзакции в секундах. Если транзакция не завершится за это время, она будет автоматически прервана (-1 - значение по-умолчанию)
- **ReadOnly**. Разрешает только операции чтения (по-умолчанию - false). Но если мы попытаемся изменить данные в этой транзакции, то, либо:
  - Выбросится исключение
  - Откатится изменение при коммите транзакции

- **RollbackFor**. Определяет, какие исключения должны вызывать откат транзакции
  - ***Пример***: `@Transactional`(rollbackFor = {`SQLException.class`, `IOException.class`})
Если выбрасывается исключение типа `SQLException` или `IOException`, транзакция будет откатана

- **NoRollbackFor**. Определяет, какие исключения не должны вызывать откат транзакции

#### 30. Singleton-антипаттерн. Если мы на класс поставим @Service, это будет Singleton?
Да, если вы аннотируете класс с помощью `@Service` в Spring, то по умолчанию он будет работать как Singleton. Это означает, что Spring создаст только один экземпляр этого класса, и этот экземпляр будет использован во всех местах, где он требуется в приложении.

#### 31. Starter в Spring. Плюсы и минусы.
Starters в Spring — это специальные артефакты, которые облегчают конфигурацию и настройку приложений. Они предоставляют преднастроенные зависимости и настройки для различных функциональностей, что позволяет разработчикам быстро и просто начать работу с определёнными аспектами Spring-приложения.

**Плюсы**:
- Упрощение конфигурации
- Согласованность
- Сокращение времени разработки
- Модульность
- Документация и поддержка

**Минусы**:
- Избыточные зависимости
- Меньшая гибкость
