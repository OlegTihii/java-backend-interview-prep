+++
title = 'Spring'
weight = 3
bookFlatSection = true
+++

## Spring

#### 1. Зачем мы используем Spring? Почему его так любят?
*Spring* — это один из самых популярных фреймворков для разработки приложений на Java. Его используют благодаря широкому набору возможностей, гибкости и модульности, что упрощает разработку корпоративных приложений.

---
#### 2. Inversion of Control.
Это принцип, при котором мы передаем управление созданием и настройкой объектов Spring-у

---
#### 3. Dependency Injection.
*Dependency Injection* (внедрение зависимостей) — это способ предоставления объекту его зависимостей извне, вместо того чтобы объект создавал их самостоятельно. DI упрощает управление зависимостями и делает код более модульным, тестируемым и легко расширяемым.

---
***Dependency Injection vs dependency lookup***

|**Критерий**|**Dependency Injection**|**Dependency Lookup**|
|---|---|---|
|**Суть**|Зависимости предоставляются извне (контейнером или фреймворком).|Объект сам запрашивает зависимости (чаще из контекста).|
|**Простота тестирования**|Легче тестировать, зависимости можно заменять mock-объектами.|Требует мокирования контекста или фабрики для тестов.|
|**Уровень контроля**|Контейнер управляет зависимостями, объект их не создаёт.|Объект сам решает, как получить зависимости.|
|**Пример**|Spring внедряет зависимость через аннотации или XML-конфигурацию.|Вручную вызов метода `ApplicationContext.getBean(...)`.|

---
***Какие способы внедрения зависимостей знаешь?***

Существует три способа внедрения зависимостей:
- Через конструктор
- Через сеттер 
- Через поля

| **Способ**                    | **Описание**                                                                | **Плюсы**                                                                                            | **Минусы**                                                                                         | **Примеры использования**                                     |
| ----------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **Через конструктор**         | Зависимости передаются при создании объекта.                                | - Гарантия неизменяемости.  <br>- Обязательные зависимости явно видны.  <br>- Высокая тестируемость. | - Неудобно для большого числа зависимостей.  <br>- Не подходит для опциональных зависимостей.      | Когда зависимости обязательны и не изменяются после создания. |
| **Через setter**              | Зависимости устанавливаются с помощью метода после создания объекта.        | - Подходит для опциональных зависимостей.  <br>- Зависимости можно изменять в runtime.               | - Возможна ситуация, когда объект используется без установленной зависимости.  <br>- Менее явный.  | Когда зависимости опциональны или могут изменяться.           |
| **Через поля (field)**        | Зависимости внедряются напрямую в поля объекта, обычно с помощью аннотаций. | - Минимум кода.  <br>- Простота при использовании фреймворков (Spring, CDI).                         | - Сложнее тестировать.  <br>- Нарушение принципа явности зависимостей.  <br>- Отсутствие контроля. | Быстрое внедрение в Spring через `@Autowired`.                |


---
***Почему лучше использовать конструктор?***

- Неизменяемость: Зависимости устанавливаются один раз при создании объекта, и их невозможно изменить.
- Обязательность зависимостей: Устанавливает чёткое требование, что объект не может существовать без переданных зависимостей.
- Тестируемость: Проще создавать mock-объекты для тестов.
- Явность: Видно, какие зависимости требуются для работы объекта.

---
***Когда пригодится способ внедрения через setter?***

- Опциональные зависимости: Зависимость не обязательна для работы объекта и используется только в некоторых сценариях.
- Динамическое изменение зависимостей: Когда требуется сменить зависимость во время выполнения программы.
- Библиотеки или старый код: Для интеграции с кодом, где нельзя контролировать процесс создания объектов.

---
#### 4. @Autowired.
Автоматически внедряет бины. Аннотацией `@Autowired` помечают:
- Сеттер
- Поле
- Конструктор

---
#### 5. @Qualifier vs @Primary.
Если есть два одинаковых бина (по типу и имени) Spring не знает какой именно использовать и выдает *exception*. Если над одним из этих бинов установлена `@Primary`, то его использовать предпочтительнее. Но если нам нужно использовать в работе оба этих бина, можно над каждым поставить `@Qualifier` и задать имя, для идентификации этих бинов (работает только с `@Autowired`)

|**Аннотация**|**Описание**|**Когда использовать**|
|---|---|---|
|**`@Primary`**|Указывает бин по умолчанию при выборе среди нескольких.|Когда нужен бин, который используется чаще всего.|
|**`@Qualifier`**|Явно указывает, какой бин использовать среди нескольких.|Когда нужно внедрить конкретный бин, несмотря на наличие `@Primary`.|

---
#### 6. Что такое Bean?
Bean в Spring — это объект, управляемый контейнером Spring IoC. Это основной строительный блок приложения, который регистрируется и конфигурируется контейнером.

---
***@Bean***

Аннотация `@Bean` используется для указания метода, который возвращает объект(бин) и эти бины в дальнейшем можно внедрять в другие компоненты.

Аннотация `@Bean` используется для явного объявления бина в Java-конфигурации (в классе, помеченном как `@Configuration`).

Также можно использовать методы по умолчанию для определения бинов. Это позволяет создавать конфигурации бинов путем реализации интерфейсов с определениями бинов в методах по умолчанию.

```java
public interface BaseConfig {
    @Bean
    default TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
@Configuration
public class AppConfig implements BaseConfig {
}

```

---
***Что такое BeanDefinition?***

`BeanDefinition` — это метаданные, описывающие, как должен быть создан, конфигурирован и управляем конкретный бин.

Он содержит:
- Класс бина.
- Его скоуп (например, singleton или prototype).
- Зависимости.
- Методы инициализации и уничтожения.

---
***Как Spring создает бины?***

- **Чтение конфигурации:**
    - Spring считывает конфигурацию из `@Configuration`, XML или аннотаций на классах.
- **Создание BeanDefinition:**
    - На основе конфигурации Spring формирует `BeanDefinition` для каждого бина.
- **Инициализация бина:**
    - Вызывается конструктор или фабричный метод.
    - Выполняется внедрение зависимостей (через конструктор, поля или сеттеры).
- **Обработка бина:**
    - Постобработка через `BeanPostProcessor` (например, для работы с `@Autowired` или `@PostConstruct`).
- **Добавление в контейнер:**
    - Готовый бин помещается в `ApplicationContext`.


---
***Скоуп бинов. Web скоуп.***

- Singleton
  - Для каждого бина создается только один экземпляр на весь контекст приложения и переиспользуется везде, где он требуется
  - Используется по-умолчанию
  - Жизненный цикл бина начинается при загрузке контекста, и заканчивается при его завершении

- Prototype
  - Каждый раз, когда запрашивается бин, создается новый экземпляр
  - Бины со скоупом `prototype` не уничтожаются Spring, так как они выходят из его контроля сразу после создания
  - **НЕ ХРАНЯТСЯ** в контексте Spring-а


Web скоуп:

|**Скоуп**|**Описание**|**Жизненный цикл**|
|---|---|---|
|**`request`**|Создаётся один экземпляр бина на каждый HTTP-запрос.|Бин существует только в рамках одного HTTP-запроса.|
|**`session`**|Создаётся один экземпляр бина на каждую HTTP-сессию.|Бин живёт в течение одной HTTP-сессии.|
|**`application`**|Создаётся один экземпляр бина на весь `ServletContext` (аналогично синглтону, но для веб-приложения).|Бин существует в рамках всего времени работы веб-приложения.|
|**`websocket`**|Создаётся один экземпляр бина на каждую WebSocket-сессию.|Бин живёт в течение времени существования WebSocket-сессии.|

---
***Как создать свой Скоуп***

1. Реализуйте интерфейс Scope:

```java
public class CustomScope implements Scope {
    private Map<String, Object> beans = new HashMap<>();

    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        return beans.computeIfAbsent(name, k -> objectFactory.getObject());
    }

    @Override
    public Object remove(String name) {
        return beans.remove(name);
    }
    // Реализуйте другие методы...
}

```

2. Зарегистрируйте его в контексте:

```java
@Bean
public static CustomScopeConfigurer customScopeConfigurer() {
    CustomScopeConfigurer configurer = new CustomScopeConfigurer();
    configurer.addScope("customScope", new CustomScope());
    return configurer;
}

```

---
***Как конфигурируется бин?***

1. Аннотации (`@Bean`, `@Component`, `@Value`, `@Scope`).
2. XML-конфигурацию.
3. Java-код (в классе с `@Configuration`).
4. Средства типа `@PostConstruct` и `@PreDestroy` для управления жизненным циклом.

---
***В чем проблема того, что мы не можем final поле сделать в Bean-е?***

Если в бине есть `final` поле, то оно должно быть инициализировано в момент создания объекта.
Spring может не знать значения для этого поля на этапе создания объекта, так как внедрение зависимостей происходит после вызова конструктора (например, через `@Autowired`).

---
***Можно вставить Bean в статическое поле?***

Нет, Spring не поддерживает внедрение зависимостей в статические поля напрямую.
Решение: Используйте вручную сеттер или вызовите контекст через `ApplicationContext`.

---
***Как сделать ленивую инициализацию бина?***

Используйте аннотацию `@Lazy`.

---
#### 7. Жизненный цикл Bean. Вопросы связанные с классами входящими в жизненный цикл бина
Spring управляет созданием, инициализацией и уничтожением бинов в рамках контейнера IoC. Этот жизненный цикл можно разделить на несколько этапов.

**Создание бина** -> **Внедрение зависимостей** -> **Постобработка** -> **Инициализация** -> **Использование** -> **Уничтожение**


{{< figure src="Spring_Bean_Life_cycle_Flow.png" >}}

- Сначала мы предоставляем наши Bean Definitions IoC контейнеру 
- IoC-контейнер сортирует Bean Definitions чтобы сначала создавать те, которые не имеют зависимостей, и затем те, которые зависят от других бинов
- Затем итерируется по всем Bean Definitions и инициализирует их 
- Далее вызываются PostConstruct методы
- Перед и после инициализации вызываются методы BeanPostProcessor
- На выходе получаем готовый бин. Если у этого бина скоуп singleton - храним его в ассоциативном массиве IoC контейнера. Если же другой скоуп - бин сразу же возвращается
- Для всех бинов, которые находятся в IoC контейнере, перед его завершением вызывается `@PreDestroy` метод 

|**Этап**|**Описание**|**Методы/Аннотации**|
|---|---|---|
|**Создание бина**|Spring создает экземпляр бина, используя конструктор или фабричный метод.|Конструктор бина (или фабричный метод).|
|**Внедрение зависимостей**|После создания, Spring внедряет все необходимые зависимости (через конструктор, поля, или сеттеры).|`@Autowired`, `@Inject`, конструкторы, сеттеры.|
|**Постобработка**|Бин проходит через постобработчики перед инициализацией. Это этап, на котором можно изменить состояние бина.|`BeanPostProcessor` — `postProcessBeforeInitialization`, `postProcessAfterInitialization`.|
|**Инициализация**|Если бин реализует интерфейсы `InitializingBean` или использует аннотации `@PostConstruct`, вызываются методы инициализации.|`afterPropertiesSet()`, `@PostConstruct`, пользовательские методы инициализации через `@Bean(initMethod)`.|
|**Использование**|Бин доступен для использования в приложении. Это этап, когда бин полностью готов для работы.|Использование бина через `@Autowired` или прямые вызовы методов.|
|**Уничтожение**|Когда контейнер Spring уничтожает бин (особенно для синглтонов), вызываются методы очистки.|`destroy()`, `@PreDestroy`, пользовательские методы уничтожения через `@Bean(destroyMethod)`.|

---
#### 8. @ComponentScan.
Аннотация `@ComponentScan` указывает Spring где искать классы, помеченные аннотацией `@Component` или его производной (`@RestController`, `@Controller`, `@Repository`, `@Service` и т.д)

---
#### 9. @Conditional в Spring.
Аннотация `@Conditional` в Spring используется для того, чтобы условно подключать бины или выполнять конфигурации только при соблюдении определённых условий. Она позволяет гибко управлять поведением приложения, включая или исключая определенные компоненты на основе внешних или внутренних условий.

---
***Что такое @ConditionalOnBean, @ConditionalOnProperty?***


---
#### 10. @Service, @Repository, @Component.

|**Аннотация**|**Описание**|**Использование**|**Семантика**|
|---|---|---|---|
|**`@Component`**|Общая аннотация для обозначения компонента, который будет управляться контейнером Spring.|Для обычных бинов.|Может быть использована для любых типов компонентов. Обычно используется, когда нет более точного типа.|
|**`@Service`**|Специализация `@Component`, указывающая, что бин представляет собой сервисный слой.|Для сервисов.|Используется для классов, реализующих бизнес-логику. По сути, это более семантическое обозначение, чем `@Component`.|
|**`@Repository`**|Специализация `@Component`, указывающая, что бин представляет собой слой доступа к данным (DAO).|Для классов, работающих с данными.|Используется для классов, которые инкапсулируют логику доступа к данным (например, через JDBC или JPA). Аннотация также может активировать обработку исключений, специфичных для DAO.|

---

***Singleton-антипаттерн. Если мы на класс поставим @Service, это будет Singleton?***

Если вы ставите аннотацию `@Service`, Spring создаёт бин с **по умолчанию синглтон**. Однако это не является Singleton-антипаттерном, поскольку Spring управляет жизненным циклом и внедрением зависимостей, что решает многие проблемы, присущие обычному Singleton.

---
#### 11. @Controller и @RestController.
- `@Controller` В основном используется для возврата веб-страниц. Если нужно вернуть данные (например, JSON), нужно добавить `@ResponseBody` к методу
- `@RestContoller` Это комбинация `@Controller` и `@ResponseBody`. Используется в REST.
Всегда возвращает данные (например, JSON или XML) в теле HTTP-ответа.
Нет необходимости добавлять `@ResponseBody` к каждому методу.

---
#### 12. @ResponseBody vs ResponseEntity.
- *ResponseEntity* — это объект, который содержит как тело ответа, так и HTTP-статус (например, 200 OK, 404 Not Found) и заголовки. Используется для более гибкого управления HTTP-ответами
- `@ResponseBody` Аннотация, которая указывает, что результат метода контроллера должен быть возвращен как тело HTTP-ответа (например, JSON, XML)

---
#### 13. Spring MVC. Что это? Какие проблемы решает?
Spring MVC — это один из модулей Spring Framework, предназначенный для разработки веб-приложений на основе шаблона Model-View-Controller. Решает следующие проблемы

- Чёткое разделение логики. Разбиваем логику на MVC
- Поддержка различных шаблонизаторов. JSP, Thymeleaf и т.д
- Упрощает обработку HTTP-запросов через контроллеры

---
#### 14. Парадигма AOP.
*AOP* - это способ добавить в программу дополнительные функции, не трогая основной код программы.
Например, у нас есть метод, который что-то делает. Но нам нужно, чтобы перед началом и в конце работы этого метода писался лог. Вместо того чтобы добавлять этот код логирования в каждый метод руками - можно вынести его в отдельное место (аспект), а Spring сам "вставит" его туда, где нужно, без изменений основного кода.

---
#### 15. Циклическая зависимость.
Циклическая зависимость - это когда два класса взаимно ссылаются друг на друга через аннотацию `@Autowired`. Это может вызвать проблему циклической зависимости, которую Spring Framework не сможет разрешить. Для решения этой проблемы можно использовать один из следующих подходов:

- Внедрять зависимости через set-ер
- Использование `@Lazy`. Аннотация `@Lazy` откладывает создание бина до момента его использования, что позволяет разорвать круг

```java
@Component
public class BeanA {
    private final BeanB beanB;

    @Autowired
    public BeanA(@Lazy BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {
    private final BeanA beanA;

    @Autowired
    public BeanB(@Lazy BeanA beanA) {
        this.beanA = beanA;
    }
}
```

---
#### 16. Spring Boot
*Spring Boot* — это фреймворк на основе Spring, который позволяет быстрее и проще создавать готовые к работе приложения. Ключевые преимущества:

- Стартеры — это готовые наборы библиотек (модулей), которые включают все необходимые зависимости для работы с конкретными технологиями
- Встроенный сервер - В Spring Boot сервер **встроен прямо в приложение**. Например, когда вы добавляете стартер `spring-boot-starter-web`, Spring Boot автоматически включает Tomcat или Jetty
- Автоматическая конфигурация - Spring Boot использует механизм **автоматической конфигурации**, который анализирует, какие библиотеки находятся в вашем проекте, и автоматически настраивает необходимые компоненты.
- Упрощение сборки - В обычном Spring для развертывания приложения вам нужно собрать WAR файл и развернуть его на сервере. В Spring Boot приложение собирается в **исполняемый JAR файл**, который содержит все зависимости и сервер.

---
***Spring Boot vs Spring***

- **Spring** — это основной фреймворк с полной конфигурацией и гибкостью.
- **Spring Boot** — это расширение Spring, которое делает процесс разработки проще, автоматизируя конфигурацию и позволяя быстро запускать приложение с минимальной настройкой.

|**Критерий**|**Spring**|**Spring Boot**|
|---|---|---|
|**Цель**|Мощный фреймворк для создания Java-приложений.|Упрощение разработки с использованием Spring. Автоматизация конфигурации.|
|**Конфигурация**|Требуется вручную настроить XML или Java-конфигурацию.|Автоконфигурация, минимальные настройки для старта проекта.|
|**Запуск**|Нужно вручную настроить веб-сервер (например, Tomcat).|Встроенные серверы (Tomcat, Jetty, Undertow) для простого запуска.|
|**Гибкость**|Большая гибкость, полная настройка каждого компонента.|Меньше гибкости, но намного быстрее и проще для старта проекта.|
|**Сложность**|Более высокая сложность настройки и конфигурации.|Упрощенная настройка и конфигурация.|
|**Использование**|Используется, когда нужна полная настройка и контроль.|Используется для быстрого старта и простоты разработки.|
|**Конфигурационные файлы**|Использует XML или Java-конфигурацию для настройки бинов.|Использует application.properties или application.yml для настройки.|

---
***Как Spring Boot работает под капотом***

1. **Автоконфигурация (Auto Configuration)**:
    
    - Spring Boot анализирует классы и зависимости в вашем проекте и пытается настроить приложение так, чтобы оно работало "из коробки".
    - Например, если в проекте есть зависимость от `spring-boot-starter-web`, то Spring Boot автоматически настраивает `DispatcherServlet`, который обрабатывает HTTP-запросы.
2. **Сканирование компонентов**:
    
    - При запуске приложения Spring Boot сканирует пакеты для поиска аннотированных классов (например, с аннотациями `@Component`, `@Service`, `@Repository`, `@Controller` и т. д.), чтобы зарегистрировать бины.
    - Это сканирование начинается с класса, аннотированного `@SpringBootApplication`, который обычно находится в корне проекта. Пакеты и подпакеты, расположенные ниже этого класса, будут сканироваться на наличие компонентов.
3. **Встроенный сервер**:
    
    - Spring Boot может использовать встроенные сервера, такие как Tomcat, Jetty или Undertow, что позволяет запустить приложение как самодостаточный исполнимый JAR или WAR файл.
4. **Процесс инициализации**:
    
    - Когда приложение запускается, Spring Boot автоматически запускает и настраивает все необходимые компоненты и зависимости. Весь процесс инициализации централизован и автоматизирован.
5. **Основной класс с `@SpringBootApplication`**:
    
    - Этот класс является точкой входа в приложение. Он выполняет несколько задач:
        - Включает автоматическое конфигурирование с помощью `@EnableAutoConfiguration`.
        - Разрешает сканирование компонентов с помощью `@ComponentScan`.
        - Включает настройку конфигурации Spring с помощью `@Configuration`.

---
***Где Spring Boot ищет бины?***

1. **Основной класс с `@SpringBootApplication`**:
    
    - Spring Boot начинает сканировать пакеты с местоположения класса, аннотированного `@SpringBootApplication`.
    - Все классы в этом пакете и его подпакетах будут автоматически обработаны на наличие аннотаций для создания бинов (например, `@Component`, `@Service`, `@Repository` и т. д.).
2. **Пакет с `@SpringBootApplication`**:
    
    - По умолчанию Spring Boot сканирует только текущий пакет и его подпакеты. **Поэтому важно**, чтобы основной класс с аннотацией `@SpringBootApplication` находился в корне пакета, чтобы гарантировать, что все компоненты будут найдены.
3. **Дополнительные настройки сканирования**:
    
    - Можно явно указать, какие пакеты нужно сканировать, с помощью аннотации `@ComponentScan`:
 
```java
@SpringBootApplication
@ComponentScan(basePackages = "com.example.myapp")
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```
        
Это полезно, если компоненты находятся в другом пакете или если вы хотите ограничить область сканирования.

4. **Использование профилей**:
    
    - Если в проекте используются разные профили (например, для разных сред), Spring Boot будет также искать компоненты, соответствующие активному профилю, при условии что они аннотированы как `@Profile`.

---
#### 17. Spring JDBC.
*Spring JDBC* — это модуль Spring, который упрощает взаимодействие с базами данных, используя JDBC (Java Database Connectivity). Он предлагает упрощённый подход к выполнению SQL-запросов, обработке результатов и управлению ресурсами.

---
#### 18. Spring Data JPA.
*Spring Data JPA* — это модуль Spring, который упрощает работу с JPA (Java Persistence API) и предоставляет удобные способы доступа к данным. Он позволяет разработчикам сосредоточиться на бизнес-логике, не заботясь о низкоуровневых деталях доступа к данным.

---
#### 19. Блокировка по умолчанию в Spring.
В Spring, по умолчанию, используется **оптимистичная блокировка** для управления конкурентным доступом к данным. Это означает, что при обновлении сущностей предполагается, что конфликты не произойдут, и изменения вносятся в базу данных без блокировок.

---
#### 20. @Transactional. Как работает?
`@Transactional` — это аннотация, которая позволяет автоматически управлять транзакциями. Когда метод аннотирован `@Transactional`, Spring берет на себя начало, коммит или откат транзакции

---
***Что можно пометить аннотацией @Transactional?***

- Класс. Все его методы станут `@Transactional` 
- Метод

---
***Дефолтный propagation.***

Propagation.REQUIRED

---
***Атрибут propagation у @Transactional.***

- **REQUIRED** — применяется по умолчанию. При входе в `@Transactional` метод будет использована уже существующая транзакция или создана новая транзакция, если никакой еще нет
- **REQUIRES_NEW** — для внутреннего метода создается своя отдельная транзакция. Пока выполняется внутренний метод, внешняя транзакция приостанавливается. Результат выполнения внутренней - не повлияет на результат выполнения внешней
- **NESTED** — создаёт под транзакцию внутри основной транзакции. Эта под транзакция может быть откатана отдельно от основной, но зависит от успешного завершения основной транзакции. Если основная транзакция откатится, под транзакция тоже откатится, даже если она завершилась успешно
- **MANDATORY** — требует внешнюю транзакцию, а иначе выбрасывается исключение
- **SUPPORTS** — метод будет выполняться в рамках транзакции, если она существует. Если ее нет, метод выполнится без транзакции
- **NOT_SUPPORTED** — метод всегда выполняется вне транзакции, даже если существует текущая транзакция. Текущая транзакция приостанавливается
- **NEVER** — запрещает выполнение метода в транзакции

---
***Какие способы управления транзакциями в Spring вы знаете?***

- Аннотация `@Transactional`
- TransactionManager
- TransactionTemplate

*TransactionManager* и *TransactionTemplate*

- Когда требуется точный контроль над транзакциями (например, управлять несколькими транзакциями в одном потоке)

*@Transactional*

- Когда нужно простое управление транзакциями
- Когда транзакция не требует сложной логики управления

---
***@Transactional повесить на private метод?***


---
***Какие еще есть атрибуты у @Transactional?***

- **Isolation**. Задает уровень изолированности для транзакции (default - уровень изоляции по-умолчанию БД)
- **TimeOut**. Задаёт время ожидания транзакции в секундах. Если транзакция не завершится за это время, она будет автоматически прервана (-1 - значение по-умолчанию)
- **ReadOnly**. Разрешает только операции чтения (по-умолчанию - false). Но если мы попытаемся изменить данные в этой транзакции, то, либо:
  - Выбросится исключение
  - Откатится изменение при коммите транзакции

- **RollbackFor**. Определяет, какие исключения должны вызывать откат транзакции
  - ***Пример***: `@Transactional`(rollbackFor = {`SQLException.class`, `IOException.class`})
Если выбрасывается исключение типа `SQLException` или `IOException`, транзакция будет откатана

- **NoRollbackFor**. Определяет, какие исключения не должны вызывать откат транзакции

---
***@Transaction Что будет если вызвать метод из метода в одном классе?***

---

#### 21. @Async

---
#### 22. Starter в Spring. Плюсы и минусы.
Starters в Spring — это специальные артефакты, которые облегчают конфигурацию и настройку приложений. Они предоставляют преднастроенные зависимости и настройки для различных функциональностей, что позволяет разработчикам быстро и просто начать работу с определёнными аспектами Spring-приложения.

**Плюсы**:
- Упрощение конфигурации
- Согласованность
- Сокращение времени разработки
- Модульность
- Документация и поддержка

**Минусы**:
- Избыточные зависимости
- Меньшая гибкость

---

#### 23. Spring Criteria api

---
#### 24. @Scheduled

---
#### 25. Понятие Controller и Servlet в Java. Это одно и то же? Если разное, в чем отличия?

---
#### 26. Что такое объект Filter? В какой момент вызывается?

---
#### 27. Что такое ApplicationContext?

---
***Расскажи про разницу  между ApplicationContext и BeanFactory.***

---
#### 28. Зачем нужны аннотации RequestParam и PathVariable?

---
#### 29. @ConfigurationProperties? ConfigurationProperties vs Value

---
#### 30. @Value. Что это?

---
#### 31. Как работает DispatcherServlet?

---
#### 32. Варианты обработки Exceptions в Spring

---
***Как транзакционная логика обрабатывает исключения?***

---
#### 33. Контекст Spring-а. Можно ли поднять несколько контекстов?

---
#### 34. @Configuration. Является Configuration компонентом? Какую доп логику Configuration реализует?

---
#### 35. @PostConstruct. Что это? Сколько @PostConstruct можно задекларировать в бине?

---
#### 36. Dependency management в Spring boot