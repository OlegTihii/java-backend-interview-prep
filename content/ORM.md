## ORM

#### 1. Что такое Hibernate, JPA, JDBC, ORM?
*Hibernate* - это ORM Framework (один из самых распространённых JPA реализаций) 

*JPA* - это спецификация Java, которая предоставляет набор интерфейсов/аннотаций

*ORM* - процесс преобразования объектно-ориентированной модели в реляционную и наоборот

*JDBC* - низкоуровневый API для взаимодействия с базами данных. 

#### 2. Плюсы и минусы ORM.
**Плюсы:**
- Позволяет бизнес методам обращаться не к БД, а к Java классам
- Ускоряет разработку приложения
- Основан на JDBC
- Сущности основаны на бизнес-задачах, а не на струкруре БД
- Управление транзакциями

**Минусы:**
- **Потенциальная потеря производительности** — автоматическая генерация SQL-запросов может быть менее оптимальной, чем ручное написание запросов.
- **Сложные запросы** — ORM плохо справляется с очень сложными SQL-запросами, такими как сложные агрегатные функции или многоуровневые JOIN'ы.

#### 3. Как создать Entity и что это такое?
Это класс, помеченный аннотацией `@Entity`, нужен для маппинга Java объектов в БД объекты и наоборот. Она должна соответствовать следующим условиями:

- Должен иметь пустой конструктор
- Не может быть вложенным, интерфейсом, ENUM, или final
- Не может содержать final полей
- Хотя бы одно поле помеченное аннотацией `@Id `
- Аннотация `@Entity` над классом
- Должен быть `POJO` (все поля private + getter-ы и setter-s к ним)

#### 4. Может ли наследоваться от не-Entity классов?
Да. Может

#### 5. Может ли наследоваться от других Entity классов?
Да. Может

#### 6. Почему мы не можем использовать final классы в качестве Entity?
Превращение Entity в final ограничивает способность Hibernate использовать прокси, что в свою очередь, не позволяет Hibernate применять ленивую загрузку. Потому что, прокси-класс должен наследоваться от класса-сущности, чтобы заменить его настоящим объектом при необходимости, но т.к final запрещает наследование от классов - мы этого сделать не можем

#### 7. Что такое Proxy и для чего используется?
**Hibernate Proxy** — это объект-заместитель (placeholder) для реального объекта, который загружается "лениво" (lazy loading). Это значит, что Hibernate создает прокси-объект вместо настоящего объекта из базы данных, и реальные данные загружаются только при первом доступе к ним. Это помогает оптимизировать производительность, загружая данные только тогда, когда они действительно нужны.

#### 8. FetchType.
*LAZY* - данные поля будут загружены не сразу, а только при обращении к ним

*EAGER* - связанные сущности загружаются сразу вместе с основной сущностью

- `@OneToMany` `@ManyToMany` - по-умолчанию применяется FetchType.LAZY
- `@ManyToOne` `@OneToOne` - по-умолчанию применяется FetchType.EAGER

#### 9. Жизненный цикл сущности.
В Hibernate сущность может находиться в одном из четырех состояний:
{{< figure src="Hibernate_Entity_Life_cycle.png" >}}

- **Transient (Переходное состояние) (new)**
  
Сущность только что создана с помощью оператора new, но еще не сохранена в базе данных

```java
User user = new User(); // объект пока не связан с БД
user.setName("John"); 
```

- **Persistent (Постоянное состояние) (save,persist,update,get)**

Когда объект сохранен в базе данных через EntityManager или Session, он становится постоянным. В этом состоянии Hibernate следит за объектом. Любые изменения в объекте автоматически синхронизируются с базой данных

```java
Session session = sessionFactory.openSession();
session.beginTransaction();
session.save(user); // объект теперь в состоянии persistent
```

- **Detached (Отсоединённое состояние) (session close)**

Когда сессия закрыта, объект переходит в состояние detached. Он по-прежнему связан с данными в базе, но больше не синхронизируются с ней

```java
session.close(); //  объект можно использовать, но изменения не будут сохранены в бд
```
- **Removed (Удалённое состояние)  (delete(obj))**

Когда сущность удалена из базы данных она переходит в состояние removed. В этом состоянии объект по-прежнему существует в памяти, но уже удален из базы данных

```java
session.delete(); 
```

#### 10. Кеширование.
- Кэш **1-го** уровня
  - Этот кэш всегда включен и работает на уровне сессии (у каждой сессии свой кэш и нельзя получить доступ к нему из другой сессии)
  - В кэше хранятся только сущности, у которых состояние `persistent`
  - Отслеживаемые сущности (`persistent`) хранятся в мапе, где ключ - ID сущности, а значение - сами объекты-сущности
  - При повторных запросах Hibernate использует кэшированные данные вместо выполнения нового запроса к базе данных
  - При закрытии сессии - кэш удаляется

- Кэш **2-го** уровня
  - Это дополнительный кэш, который надо включать вручную
  - Работает на уровне `SessionFactory` 
  - Используется для кэширования данных между сессиями, что позволяет повторно использовать данные, уже загруженные из базы данных
  - После закрытия `SessionFactory` - весь кэш, связанный с ним, умирает

- Кэш **3-го** уровня
  - Кэширует результаты запросов на уровне SQL-запросов (кэширует результаты выборки)

#### 11. Criteria API.
С помощью Criteria API можно создавать запросы, как будто мы строим их из частей, используя объекты и методы Java
- Создаём CriteriaBuilder. Это объект для создания запросов
- Создаём CriteraiQuery. Это объект, который описывает запрос
- Создаём Root. Это корневой объект, который представляет сущность, по которой делаем запрос

```java
// Создание CriteriaBuilder
CriteriaBuilder cb = entityManager.getCriteriaBuilder();

// Создание запроса (CriteriaQuery)
CriteriaQuery<User> query = cb.createQuery(User.class);

Root<User> userRoot = query.from(User.class);

// Условия для выборки (где name = "John")
query.select(userRoot).where(cb.equal(userRoot.get("name"), "John"));

// Выполнение запроса
List<User> users = entityManager.createQuery(query).getResultList();
```

#### 12. HQL и JPQL.
Являются объектно-ориентированными языками запросов, схожими по природе с SQL

*HQL* полностью объектно-ориентирован и расширяет JPQL

*JPQL* - это стандарт JPA, который поддерживается всеми реализациями JPA, а HQL - реализация Hibernate

#### 13. EntityManager + EntityManagerFactory / SessionFactory + session.
Разница в том, где они используются. 

EntityManager и EntityManagerFactory - это *JPA*.

Session и SessionFactory - *Hibernate*. 

Session - основной интерфейс для взаимодействия с базой данных в Hibernate. Создается из SessionFactory 

#### 14. Проблема N + 1.
Это проблема, которая возникает, когда приложение делает слишком много запросов к базе данных, когда можно обойтись одним.

**Пример:**

Представь, что у тебя есть две связанные сущности: User (пользователь) и Order (заказ). Каждый пользователь может иметь много заказов.

Допустим, ты хочешь получить список всех пользователей и их заказов. Проблема N+1 возникает, когда вместо одного запроса к базе данных для получения всех пользователей и их заказов приложение сначала делает 1 запрос, чтобы получить всех пользователей, а затем делает N дополнительных запросов — по одному для каждого пользователя, чтобы получить его заказы

```java
@Entity
public class User {
    @Id
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders;
}

@Entity
public class Order {
    @Id
    private Long id;

    private String item;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

**Как избежать проблемы N + 1**
- JOIN FETCH. Это способ сказать Hibernate загрузить связанные данные вместе с основными (типа обычного JOIN-а)

```java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllUsersWithOrders();
```

- Использовать `FetchType.EAGER` вместо `FetchType.LAZY`
- Использовать EntityGraph. Указываем, какие данные загружать в конкретных запросах, не изменяя сущности (как в случае с жадной загрузкой)

```java
@EntityGraph(attributePaths = {"orders"})
List<User> findAll();
```

#### 15. Что такое Entity Graph? Как им пользоваться? Как создать? Что под капотом?
*Entity Graph* — это механизм в JPA, который позволяет управлять стратегией загрузки данных, определяя, какие связанные сущности должны быть загружены сразу (eager) или отложенно (lazy). Это дает гибкость в выборе полей для загрузки в зависимости от запроса.

**Использование**:
Создается аннотацией `@NamedEntityGraph` на уровне сущности или динамически через API.

**Что под капотом**:
Entity Graphы работают на уровне SQL-запросов, добавляя нужные JOIN-ы и выбирая необходимые поля.

#### 16. Statement, Prepared statement, Callable statement.
- *Statement* - объект, который используется для формирования простых SQL запросов. Уязвим к SQL инъекциям

- *PreparedStatement*
  - Добавляет возможность динамической вставки входных параметров
  - Предотвращает SQL инъекции
  - Быстрее чем Statement, потому что использует кэширование

- *CallableStatement* - для вызова хранимых процедур

#### 17. Блокировка или локи.
Блокировки (или локи) в базе данных — это механизм, который помогает управлять параллельным доступом к одним и тем же данным, чтобы избежать ошибок и конфликтов. Есть два типа блокировок:
- **Оптимистическая блокировка**. При сохранении данных проверяется, не изменились ли они с момента их чтения. Если изменились — происходит ошибка, и нужно повторить транзакцию.
- **Пессимистическая блокировка**. Означает, что данные блокируются сразу, чтобы другие транзакции не могли их изменить, пока текущая транзакция не завершится.


#### 18. Как реализована связь ManyToMany?
Для реализации такого вида связи создается промежуточная таблица для хранения идентификаторов обеих сущностей
*Пример*: Учителя могут преподавать несколько предметов, каждый предмет может преподаваться несколькими преподавателями

#### 19. LazyInitializationException.
Это происходит, когда объект был загружен с ленивой загрузкой, но его данные пытаются быть использованы после закрытия сессии

```java
public void printAuthorBooks(Long authorId) {
    Session session = sessionFactory.openSession();
    Author author = session.get(Author.class, authorId);
    session.close();
    
    // Попытка доступа к ленивой коллекции после закрытия сессии
    System.out.println(author.getBooks());  // Может вызвать LazyInitializationException
}
```

- Как решить?
  - JOIN FETCH. Это способ сказать Hibernate загрузить связанные данные вместе с основными (типа обычного JOIN-а)
  - Использовать EntityGraph. Указываем, какие данные загружать в конкретных запросах, не изменяя сущности (как в случае с жадной загрузкой) 

#### 20. Что такое SQL-инъекция?
Это тип уязвимости, которая позволяет злоумышленникам вмешиваться в запросы к базе данных, чтобы выполнить вредоносные команды

```sql
SELECT * FROM users WHERE username = 'user' OR '1'='1' AND password = 'password';
```

- Последствия SQL инъекций:
  - Войдет в систему обходя проверку логина и пароля
  - Возможность удалить важные данные из БД
  - Возможность изменить данные в БД
  - Доступ к конфиденциальной информации

- Как избежать:
  - Использовать PreparedStatement
  - Использовать Hibernate

#### 21. Проблемы JOIN FETCH.
- Проблема
  - Дублирование данных. При загрузке основной сущности с её связанными сущностями результаты могут содержать дубликаты

- Решение
  - Использовать DISTINCT, чтобы избежать дубликатов 
   ```sql
   SELECT DISTINCT o FROM Order o JOIN FETCH o.items
   ```
  - Использование Set для хранения связных элементов

#### 22. Связи OneToMany, ManyToOne, ManyToMany.
- *OneToMany* — одна сущность (родитель) связана с множеством дочерних сущностей (пример: один игрок — много матчей).
- *ManyToOne* — множество сущностей связано с одной сущностью (пример: много матчей — один игрок).
- *ManyToMany* — множество сущностей связано с множеством других сущностей (пример: много игроков — много турниров).

#### 23. OneToMany: разница между List и Set.
- *List* — сохраняет порядок элементов и допускает дубликаты, но может потребовать дополнительных индексов для оптимизации запросов.
- *Set* — не содержит дубликатов и более производительно для проверок на уникальность, но порядок элементов не сохраняется.

#### 24. Логи в Hibernate.
Hibernate предоставляет детализированные логи через категорию `org.hibernate.SQL`. Это помогает отслеживать сгенерированные SQL-запросы, параметры и выполнение транзакций. Включение логов может помочь отладить проблемы с производительностью или запросами, но может замедлить выполнение при большом количестве запросов.

```java
log4j.logger.org.hibernate.SQL=DEBUG
log4j.logger.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```
