+++
title = 'Тестирование'
weight = 1
bookFlatSection = true
+++

## Тестирование

#### 1. На чем пишутся тесты?
- *Unit-тесты*: В основном используются фреймворки **JUnit** для написания модульных тестов в Java.
- *Интеграционные тесты*: Используют **Spring Test**, **Testcontainers** для интеграционного тестирования с базами данных и внешними системами.
- *Mocking*: Фреймворки, такие как **Mockito** применяются для создания заглушек (mock-объектов) в unit-тестах.
- *UI-тесты*: Для тестирования интерфейсов часто используют **Selenium**.
- *Performance тесты*: Инструменты вроде **JMeter**.

---
#### 2. Какие требования к покрытию тестами?
Требования к покрытию тестами зависят от проекта и его критичности:

- *Unit-тесты*: Обычно на уровне не ниже 70-80% покрытия кода. Это включает тестирование основных методов и критически важных участков логики.
- *Интеграционные тесты*: Покрытие может быть ниже, но важно, чтобы были проверены ключевые интеграции с внешними системами и базами данных.
- *End-to-End тесты*: Покрытие определяется основными пользовательскими сценариями (Critical Path), они могут покрывать 10-20% кода, но проверять важные бизнес-операции.

>*Прим*.
>В целом, критически важные части кода требуют высокого покрытия тестами, а для менее критичных модулей порог покрытия может быть ниже.

---
#### 3. Mock vs spy

|**Критерий**|**Mock**|**Spy**|
|---|---|---|
|**Описание**|Полностью имитирует поведение объекта. Вы задаёте ожидаемые ответы на вызовы методов.|Реальный объект, но с возможностью "шпионить" за вызовами методов.|
|**Подход**|Заменяет объект, тестируется только взаимодействие (behavior verification).|Используется реальный объект, но вы можете подменять результаты вызовов его методов.|
|**Когда использовать**|Когда необходимо полностью изолировать тестируемый объект от зависимости.|Когда хотите протестировать реальный объект, но также отследить вызовы его методов.|
|**Пример использования**|Проверка взаимодействия с внешней зависимостью, например, базой данных.|Проверка поведения конкретного метода объекта, оставаясь близко к реальной логике.|
|**Типы подмен**|Вы задаёте возвращаемые значения для всех методов объекта.|Реальные методы объекта выполняются, если не настроена их подмена.|

---
#### 4. Параметризованные тесты

Параметризованные тесты позволяют запускать один и тот же тест с различными входными данными. Это удобно для проверки поведения метода на разных наборах значений.

```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4, 5})
void testWithParameters(int number) {
    assertTrue(number > 0);
}

```

 **Типы параметризованных тестов в JUnit 5:**

|**Аннотация**|**Описание**|
|---|---|
|`@ValueSource`|Передаёт фиксированные наборы данных (массив значений).|
|`@CsvSource`|Передаёт данные в формате CSV.|
|`@CsvFileSource`|Загружает данные из файла CSV.|
|`@MethodSource`|Использует метод для предоставления набора данных.|
|`@EnumSource`|Передаёт значения перечислений (enums).|
